#!/bin/sh
#  -*-Perl-*-
#======================================================================#
# Run the right perl version:
if [ -x /usr/local/bin/perl ]; then
  perl=/usr/local/bin/perl
elif [ -x /usr/bin/perl ]; then
  perl=/usr/bin/perl
else
  perl=`which perl| sed 's/.*aliased to *//'`
fi

exec $perl -x -S $0 "$@"     # -x: start from the following line
#======================================================================#
#! /Good_Path/perl -w 
# line 17

# Name:   auto-test
# Author: wd (Wolfgang.Dobler@kis.uni-freiburg.de)
# Date:   12-Aug-2002
# CVS: $Id: auto-test,v 1.15 2002-09-26 14:54:14 dobler Exp $
# Description:
#   Test compilation and results on a set of sample directories to
#   validate the pencil code. Uses Perl because I started to do this with
#   the Test/Test::Harness module and because we need to do pattern
#   matching to extract the relevant output lines.
# To Do:
# - Remove directory from /var/tmp when wncountering Ctl-c
# - Investigate the return status after namelist error or similar

use strict;
use constant QUIET=>1;
use Cwd;
use Getopt::Long;
use vars qw{ %failed $ntests $test_status };


# ---------------------------------------------------------------------- #
# Test the following subdirs of samples/ :
my @sampdir = qw( conv-slab conv-slab-flat
                  helical-MHDturb interlocked-fluxrings);
# Test the following subdirs of runs/ :
my @runsdir = qw( forced/hydro1 radiation/rad1);
# ---------------------------------------------------------------------- #
## Override for testing:
#@sampdir = qw( conv-slab );
#@runsdir = qw(  );


my $tmpdir = "/var/tmp/pencil-tmp-$$";
my $cfloat = '([+-]?)(?=\d|\.\d)\d*(\.\d*)?([Ee]([+-]?\d+))?'; # regexp
                                                                 # for C float
my $noheader = "Couldn't find header line";
my $res;
my ($t_comp,$t_start,$t_run,$t_res) = (1,1,1,1); # test everything by default
my (%opts);			# variables written by GetOptions
(my $cmdname = $0) =~ s{.*/}{};
my ($debug,$help) = (0,0);

my $usage =
"Usage:  $cmdname [options]
  Test compilation and results on a set of sample directories to
  validate the pencil code. Uses Perl because we need to do pattern matching
  to extract the relevant output lines.
    If you don't have a tmp directory, $cmdname creates a link to
  $tmpdir -- both link and directory are removed after each run.
Options:
  -h,  --help           \tShow usage overview
       --clean          \tClean up (make cleann) before compiling
  -c,  --compile-only   \tTest compilation only
  -nr, --norun          \tTest compilation and starting only
  -v,  --version        \tPrint version number";

## Process command line options
GetOptions(\%opts,
	   qw( -h   --help
	            --debug
	            --clean
               -c   --compile-only
	       -nr  --norun
	       -v   --version
                             ));

if ($opts{'h'} || $opts{'help'}) { $help=1; die "$usage\n"; }
if ($opts{'v'} || $opts{'version'}) {
    $help=1;
    die '$Id: auto-test,v 1.15 2002-09-26 14:54:14 dobler Exp $ ' . "\n";
}
if ($opts{'c'} || $opts{'compile-only'}) { $t_start=$t_run=$t_res=0; }
if ($opts{'nr'} || $opts{'norun'}) { $t_run=0; }
if ($opts{'debug'}) { $debug = 1 } else { $debug = 0 }
my $clean = $opts{'clean'} ? 1 : 0;

# $t_comp .. $t_res form a hierarchy: We can't test running without
# compiling and starting
$t_start &&= $t_comp;
$t_run &&= $t_start;
$t_res &&= $t_run;

# Make sure we are in the top directory and have the right PATH
die "Need to set environment variable PENCIL_HOME\n" 
    unless (defined($ENV{PENCIL_HOME}));
my $topdir = "$ENV{PENCIL_HOME}";
chdir $topdir;
$ENV{PATH} .= ":$ENV{PENCIL_HOME}/bin";

# Autoflush stdout:
$| = 1;

# Process dirs in samples/ directory
for my $d (@sampdir) {
    test_rundir("$topdir/samples/$d");
}
# Process dirs in runs/ directory
if (-d "$topdir/runs") {
    for my $d (@runsdir) {
	test_rundir("$topdir/runs/$d");
    }
} else {
    print "Not checking in $topdir/runs : no such directory\n";
}


# ---------------------------------------------------------------------- #
sub my_ok {
# Similar to Test's and Test::Harness' ok() function: consider success if
# first two argumets are equal, otherwise report a problem and print the
# third argument (which should normally contain the output from the shell
# calls that we are normally testing here).
# Args #4 and #5 are the current run directory and the phase (compilation,
# starting, running) we are in.

    my $arg1 = shift;
    my $arg2 = shift;
    my $mesg = (shift || "<No diagnostics>"); 
    chomp($mesg);
    my $dir = shift;
    my $phase = shift;
    my $quiet = (shift || 0);

    # Allow for calls like `ok(0)' or `ok(1)':
    if (!defined($arg2)) {
	$arg2 = $arg1 ? $arg1 : 1;
    }
    if ($arg1 eq $arg2) {
	print "  ok\n" unless ($quiet);
    } else {
	print "  not ok:\n  $mesg\n";
	$test_status = 1;
	# report only first failure:
	$failed{$dir} = $phase unless defined($failed{$dir});
    }
}

sub test_shell_cmd {
    my $cmd = shift;
    my $dir = (shift || "<Unknown directory>");
    my $phase = (shift || "<Unkonwn phase>");
    my $quiet = (shift || 0);	# flag for suppressing the `ok'

    if ($debug) { print "Running `$cmd`\n" };
    my $res = `$cmd 2>&1`;
    chomp($res);
    my_ok($?,0,$res,$dir,$phase,$quiet); # $? = 0 means success
    $res;			# Return output so we can analyze it if desired
}

sub test_compile {
# Test compilation only
    if ($t_comp) {
	my $dir = shift;
	print "    Compiling..         ";
	test_shell_cmd('setup-src',$dir,"setting up directory",QUIET);
	if ($clean) {
	    test_shell_cmd('cd src; make cleann',$dir,"cleaning up",QUIET);
	}
	test_shell_cmd('cd src; make',$dir,"compilation");
    }
}

sub test_start {
# Test starting only
    if ($t_start) {
	my $dir = shift;
	print "    Starting..          ";
	test_shell_cmd('start.csh',$dir,"starting");
    }
}

sub test_run {
# Test running only (does not analyze output, but returns it)
    if ($t_run) {
	my $dir = shift;
	print "    Running..           ";
	$res = test_shell_cmd('run.csh',$dir,"running");
    }
}

sub test_results {
# Analyze results from code
    if ($t_res) {
	my $dir = shift;
	my ($rdmsg,$diagn);
	print "    Validating results..";
#	print "    [Not yet implemented]";
	my @output = split(/[\n\r]+/,$res);
	my_ok(0,0,"",$dir,"results","quiet");
	my @foutput = extract_results(\@output); # filtered output
	if ($foutput[0] ne "$noheader") {
	    my @ref_output = read_lines("reference.out",$rdmsg);
	    if ($rdmsg) {
		print " [$rdmsg]\n";
	    } else {
		my $comp = compare_results(\@ref_output,\@output,$diagn);
		my_ok($comp,1,$diagn,$dir,"results");
	    }
	} else { # No header line found
	    my_ok(0,1,join("/n",@output),$dir,"results");
	}
    }
}

sub extract_results {
# Extract result lines (header line and numerical data) from the output of
# the code
    my $lineptr = shift;
    my @lines = @$lineptr;

    my $headerpat = '^-*\s*(-+[A-Za-z0-9_]+)+-*\s*$';
    my @results = ();
    my @labels = ();
    my $body = 0;		# true after header line
    my $ncols;

    line: foreach my $line (@lines) {
	unless ($body) {
	    # Before or at header line
	    next line unless ($line =~ /$headerpat/);
	    push @results, $line;
	    $body = 1;
	    @labels = grep { /\S/ } split(/-+/,$line); # ignore empty labels
	    $ncols = @labels;
	} else {
	    # After header line
	    next unless ($line =~ /^(\s+$cfloat){$ncols}\s*$/);
	    push @results, $line;
	}
    }
    if ($body) {
	@results;
    } else {
	($noheader);
    }
}

sub read_lines {
# Read file an return hash of non-empty lines
    my $file = shift;
    my @lines = ();
    my $msg = "";

    {
	local $/ = undef;	# read in whole file
	if (open (REF, "< $file")) {
	    @lines = grep { /\S/ } split(/[\n\r]+/,<REF>);
	    # Remove leading comment sign from header line:
	    $lines[0] =~ s/^(\s*)#/$1 /;
	} else {
	    $msg = "Couldn't open $file";
	}
    }
    $_[0] = $msg;
    @lines;
}

sub compare_results {
# Compare two arrays linewise; if all lines are the same, return 1; if
# not, return 0 and write report to third argument
    my $arr1 = shift;
    my $arr2 = shift;

    my @pref = ("< ", "> ", "  "); # prefixes to mark differing lines
    my $n1 = $#$arr1;
    my $n2 = $#$arr2;
    my $N = ($n2>$n1 ? $n2 : $n1);
    my $diagn = "";
    my $equal = 1;
    for my $i (0..$N) {
	my $line1 = ($$arr1[$i] || ""); chomp $line1;
	my $line2 = ($$arr2[$i] || ""); chomp $line2;
	if ($line1 ne $line2) {
	    $diagn .= $pref[0] . $line1 . "\n" if ($line1);
	    $diagn .= $pref[1] . $line2 . "\n" if ($line2);
	    $equal = 0;
	} else {
	    if ($i == 0) {	# Keep header line for easier reading
		$diagn .= $pref[2] . $line1 . "\n";
	    }
	}
    }
    $_[0] = $diagn;		# the remaining argument (was the third one)
    $equal;
}

sub test_rundir {
# Test compilation, starting, running and results
    my $dir = shift;
    my $created_tmp = 0;

    $test_status = 0;		#  so far, everything is OK

    # Go to directory and identify it
    if (! -d $dir) {
	print STDERR "No such directory: $dir\n";
	return;
    }
    chdir $dir;
    print "\n", cwd(), ":\n";
    $ntests++;

    # Make sure we have everything we need
    if (! defined(-e 'src/run.f90')) { # has `setup-src' been run yet?
	my $res = `setup-src 2>&1`;
	if ($?) {
	    print "    Problems running setup-src:\n", $res;
	}
    }

    # Test compilation
    test_compile($dir);
    return if ($test_status);

    # Ensure we have a tmp directory and test starting and running
    return unless ($t_start);	# no need for a tmp directory unless we start
				# the code
    if (! -d 'tmp') {
	if (-l 'tmp') {
	    print "        tmp is file or empty link;\n"
		. "        removing and generating tmp -> $tmpdir\n";
	    system("rm", "tmp");
	}
	else
	{
	    print "        No tmp directory; generating tmp -> $tmpdir\n";
	}
	system("mkdir -p $tmpdir; ln -s $tmpdir tmp");
	$created_tmp = 1;
    }
    test_start($dir);
    goto cleanup if ($test_status);
    # we only get here if compiling and starting was OK
    test_run($dir);
    return if ($test_status);

    # need to check the output here..
    test_results($dir);

    # Clean up if necessary
  cleanup:
    if ($created_tmp) {
	system("rm", "tmp");
	system("rm", "-r", "$tmpdir");
    }
}


END {
    if (!$help) {
	print "\n" . "-" x 70 . "\n";
	if (%failed) {
	    print "Failed ", scalar(keys %failed),
	      " test(s) out of $ntests:\n";
	    while (my ($dir,$phase) = each %failed) {
		print "  $dir ($phase)\n";
	    }
	} else {
	    print "",
	    ($ntests>1 ? "All $ntests tests succeeded." : "Test succeeded.");
	    }
	print "\n";
    }
}

# End of file auto-test
