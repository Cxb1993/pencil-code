#!/bin/sh
#  -*-Perl-*-  (for Emacs)    vim:set filetype=perl:  (for vim)
#======================================================================#
# Work in submit directory (SGE):
#$ -cwd -V
#======================================================================#
# Run the right perl version:
if [ -x /usr/local/bin/perl ]; then
  perl=/usr/local/bin/perl
elif [ -x /usr/bin/perl ]; then
  perl=/usr/bin/perl
else
  perl=`which perl| sed 's/.*aliased to *//'`
fi

exec $perl -x -S $0 "$@"     # -x: start from the following line
#======================================================================#
#! /Good_Path/perl -w
# line 20

# Name:   pc_build
# Author: wd (wdobler [at] gmail [dot] com)
# Date:   24-Jul-2009
# Description:
#   Run the Pencil Code, using settings from the `runtime' section in
#   the appropriate configuration files.
# Usage:
#   pc_run [-v|-h]
#   pc_run [start|run]
#   pc_run [stop|reload]
# Options:
#   -h, --help      This help.
#   -f <files>,
#       --config-files=<files>
#                   Use the given <files> (a comma-separated list) as
#                   configuration files, rather than trying to find a
#                   config file base on a host ID.
#   -H <id>
#       --host-id=<id>
#                   Use the given <id> as host ID.
#   -N, --no-pencil-check
#                   Suppress pencil consistency check, irrespective of
#                   &run_pars.lpencil_check .
#   -v, --version   Print version number.
#   -q, --quiet     Be quiet.
# Examples:
#   pc_run start              # just start
#   pc_run run                # just run
#   pc_run                    # start if necessary, then run
#   pc_run start run run run  # start, then run 3 times
#   pc_run start run^3        # ditto
#   pc_run ^3                 # start if necessary, then run 3 times
#
#   pc_run stop               # stop pencil job running in current directory
#   pc_run reload             # make running pencil job reload run.in
#
# To do:
# - NEWDIR handling
# Improvements:
# - use a wrapper to die() that removes the LOCK file (except when die'ing
#   because of an existing lock file)
# - Extract common code for finding and parsing config file from here
#   and pc_run and put it into Pencil::ConfigFinder (or some 3rd module,
#   or Pencil::Util)

# Copyright (C) 2009  Wolfgang Dobler
#
# This program is free software; you can redistribute it and/or modify it
# under the same conditions as Perl or under the GNU General Public
# License, version 3 or later.

use strict;
BEGIN {
    # Make sure ${PENCIL_HOME}/lib/perl is in the Perl path
    if (-d "$ENV{PENCIL_HOME}/lib/perl") {
        unshift @INC, "$ENV{PENCIL_HOME}/lib/perl";
    } else {
        if ($0 =~ m{( .* [/\\] )}x) { unshift @INC, "$1../lib/perl"; }
    }
}

use Pencil::Util;
Pencil::Util::use_pencil_perl_module('Pencil::ConfigFinder') or die;
Pencil::Util::use_pencil_perl_module('Pencil::ConfigParser') or die;

use Getopt::Long;
# Allow for `-Plp' as equivalent to `-P lp' etc:
Getopt::Long::config("bundling");

my %opts;                     # Options hash for GetOptions

## Process command line
GetOptions(\%opts,
           qw( -h   --help
                    --debug
               -f=s --config-files=s
               -H=s --host-id=s
               -N   --no-pencil-check
               -q   --quiet
               -v   --version )
          ) or die "Aborting.\n";

my $debug = ($opts{'debug'} ? 1 : 0 ); # undocumented debug option
if ($debug) {
    printopts(\%opts);
    print "\@ARGV = `@ARGV'\n";
}

my $cmdname = (split('/', $0))[-1];

if ($opts{'h'} || $opts{'help'})    { die usage();   }
if ($opts{'v'} || $opts{'version'}) { die version(); }

my $config_files   = ($opts{'f'} || $opts{'config-files'}    || undef);
my $host_id        = ($opts{'H'} || $opts{'host-id'}         || undef);
my $suppress_check = ($opts{'N'} || $opts{'no-pencil-check'} || '');
my $quiet          = ($opts{'q'} || $opts{'quiet'}           || '');

my @config_files;
if (defined $config_files) {
    my @files = split(",", $config_files);
    @config_files = Pencil::ConfigFinder::locate_config_files(@files) ;
} else {
    mention($Pencil::ConfigFinder::debug);
    $Pencil::ConfigFinder::debug = 1 if ($debug);
    my $config_file;
    if (defined $host_id) {
        $config_file = Pencil::ConfigFinder::find_config_file_for_host($host_id);
    } else {
        $config_file = Pencil::ConfigFinder::find_config_file()
    }
    die "Fatal: Couldn't find config file.\n" unless (defined $config_file);
    push @config_files, $config_file;
    print STDERR "Found config file <$config_files[0]>\n" unless ($quiet);
}

my $parser = new Pencil::ConfigParser(@config_files);
$parser->debug(1) if ($debug);


my %runtime_params = %{$parser->get_runtime_params()};
my @runtime_keys = @{$parser->get_runtime_keys()};


## Global variables
my $data_dir = './data';
my $runtime_dir = './runtime';
my $lockfile = './LOCK';
my $errorfile = './ERROR';
my $locked = 0;
my $start_x = 'src/start.x';
my $run_x   = 'src/run.x';
my %dispatch_table = (
                      start  => \&start_cmd,
                      run    => \&run_cmd,
                      stop   => \&stop_cmd,
                      reload => \&reload_cmd,
                     );

my %settings = local_settings();
my $Ncpus = $settings{'ncpus'};
my $mpi = $settings{'mpi'};

my @subcmds = expand_cmd_sequence(@ARGV);
print STDERR "Commands: <", join(">, <", @subcmds), ">\n" if ($debug);


## Start working
update_runtime_dir();

if ($suppress_check) {
    touch("$runtime_dir/NO-PENCIL-CHECK");
}

## Setup steps:

# - lock
# - read $data_dir value from file, if present
# - catch C-c to perform ordered shutdown (in particular running our END
#   block)

cd_to_wordir();

for my $subcmd (@subcmds) {
    my $action = $dispatch_table{$subcmd};
    if (defined($action)) {
        print STDERR "Subcommand: $subcmd\n" unless ($quiet);
        &$action();
    } else {
        warn "No such subcommand: <$subcmd>\n\n";
        die usage();
    }
}

# ---------------------------------------------------------------------- #
sub start_cmd {
# Run start.x

    setup_datadir();
    run_extra_setup_script();
    honour_nostart();

    get_lock();
    mpi_run_cmd($start_x);
    clear_lock();
}
# ---------------------------------------------------------------------- #
sub run_cmd {
# Run run.x
    get_lock();
    mpi_run_cmd($run_x);
    clear_lock();
}
# ---------------------------------------------------------------------- #
sub mpi_run_cmd {
#
    my @cmd_line = @_;
    if ($mpi) {
        my $mpiexec = $runtime_params{'mpiexec'}
          or die "No mpiexec setting. Please fix your configuration.\n";
        my @mpiexec_cmd = split('\s+', $mpiexec);
        push @mpiexec_cmd, ('-np', $Ncpus);
        run_system_cmd(@mpiexec_cmd, @cmd_line);
    } else {
        run_system_cmd(@cmd_line);
    }
}
# ---------------------------------------------------------------------- #
sub run_system_cmd {
#
    my @cmd_line = @_;
    $! = 0;
    clear_error();

    if ($debug) {
        print "Running system cmd <", join("> <", @cmd_line), ">\n";
    } else {
        print "Running\n  @cmd_line\n";
    }
    my $status = system(@cmd_line);
    ($status == 0) or warn "@cmd_line failed: $!\n";
    if (-e $errorfile) {
        print "Found ERROR file from start.x\n";
        $status |= 16;
        clear_error();
    }

    die "\n" if ($status);
}
# ---------------------------------------------------------------------- #
sub local_settings {
# Return hash of local settings like number of cpus, datadir, etc.
    my %settings;

    # Compiled with MPI?
    $settings{'mpi'}
      = `fgrep -c 'mpicomm_init: MPICOMM neighbors' src/start.x` + 0;
    unless ($quiet) {
        if ($settings{'mpi'} + 0) {
            print "MPI run\n"
        } else {
            print "Non-MPI run\n";
        }
    }

    # Number of CPUs (from cparam.local)
    ($settings{'ncpus'}) = match_line_ix(
        '^ \s* integer\b [^\!]* ncpus \s*=\s* ([0-9]*)', 'src/cparam.local'
    );
    print "$settings{ncpus} CPUs\n" unless $quiet;

    return %settings;
}
# ---------------------------------------------------------------------- #
sub update_runtime_dir {
# Make sure ./runtime/ directory exists and is up to date.

    # Create dir
    unless (-d $runtime_dir) {
        mkdir $runtime_dir or die "Cannot create $runtime_dir: $!\n";
    }

    # Clean dir
    if (<$runtime_dir/*>) {
        system("rm $runtime_dir/*") == 0
          or die "Cannot clean ./runtime/: $!\n";
    }

    # Write files
    unless (-e "$runtime_dir/README") {
        touch("$runtime_dir/README",
              "runtime/\n"
              . "--------\n"
              . "This directory is created by $cmdname.\n"
              . "It can be safely removed while the code is not running.\n");
    }
}
# ---------------------------------------------------------------------- #
sub expand_cmd_sequence {
# Expand subcommand sequence, replacing <cmd>^n by <cmd> <cmd> ...
    my @cmds = @_;

    my @sequence;
    if (@cmds) {                # `pc_run' with subcommands
        for my $command (@cmds) {
            if ($command =~ /^ \s* (.*) \^ ([0-9])+ \s* $/x) {
                my ($cmd, $multiplier) = ($1, $2);
                push @sequence, ($cmd) x $multiplier;
            } else {
                push @sequence, $command;
            }
        }
    } else {                    # `pc_run' without subcommands
        my $lastproc = $Ncpus - 1;
        if (-s "data/proc${lastproc}/var.dat") { # exists & non-empty
            push @sequence, 'run';
        } else {
            push @sequence, 'start', 'run';
        }
    }

    return @sequence;
}
# ---------------------------------------------------------------------- #
sub cd_to_wordir {
# Cd to the work directory for various queuing systems
    for my $dir (
                 $ENV{PBS_O_WORKDIR},     # PBS
                 $ENV{QSUB_WORKDIR},      # SUPER-UX's nqs
                 $ENV{LOADL_STEP_INITDIR} # IBM Loadleveler
                ) {
        if (defined $dir) {
            if (-d $dir) {
                chdir $dir or die "Cannot chdir to $dir: $!\n";
                return;
            } else {
                warn "No such directory: $dir\n";
            }
       }
    }
}
# ---------------------------------------------------------------------- #
sub setup_datadir {
# Ensure we have a data/ directory with the correct subdirectory
# structure.
#
#  If we don't have a data subdirectory: stop here (it is too easy to
#  continue with an NFS directory until you fill everything up).
#
    unless (-d "$data_dir") {
        print "\n";
        print ">>  STOPPING: need $data_dir directory\n";
        print ">>  Recommended: create $data_dir as link to directory on a\n";
        print ">>  scratch disk\n";
        print ">>  Not recommended: you can generate $data_dir with\n";
        print ">>  'mkdir $data_dir', but that will most likely end up on\n";
        print ">>  your NFS file system and be slow.\n";
        print "\n";
        exit -1;
    }

    for my $subdir (subdir_list()) {
        my $dir = "$data_dir/$subdir";
        if (-d $dir) {
            opendir my $dh, $dir
              or die "Cannot read directory $dir\n";
            my @files = readdir($dh);
            # Remove everything except `.', `..', `var.dat':
            my @files_to_remove
              = grep { !m/^ ( var\.dat | \. \.? ) $/x } @files;
            @files_to_remove = map { $_ = "$dir/" . $_; } @files_to_remove;

            if (@files_to_remove) {
                print "Removing @files_to_remove\n" if $debug;
                unlink @files_to_remove
                  or die "Cannot remove all of @files_to_remove\n";
            }

            closedir $dh;
        } else {
            mkdir $dir or die "Cannot mkdir $dir: $!\n";
        }
    }
}
# ---------------------------------------------------------------------- #
sub subdir_list {
# Return list of directories below data/ that must exist
    my @subdirs = qw/ allprocs averages idl /;
    for my $i (1..$Ncpus) {
        push @subdirs, 'proc' . ($i - 1);
    }
    return @subdirs;
}
# ---------------------------------------------------------------------- #
sub run_extra_setup_script {
#  Execute some script or command specified by the user.
#  E.g. run src-to-data to save disk space in /home by moving src/ to
#  data/ and linking
    if (defined $ENV{PENCIL_START1_CMD}) {
        print "Running $ENV{PENCIL_START1_CMD}\n" unless ($quiet);
        run_system_cmd($ENV{PENCIL_START1_CMD});
    }
}
# ---------------------------------------------------------------------- #
sub honour_nostart {
#  For testing backwards compatibility, do not excecute start.x, an do not
#  delete existing var.dat (etc.) files, if a NOSTART file exists.
#  Rename time_series.dat, so run.x can write a fresh one to compare
#  against.
#
    if (-e 'NOSTART') {
        print "Found NOSTART file. Won't run start.x\n";
        stash_time_series();
        exit 0;
    }
}
# ---------------------------------------------------------------------- #
sub match_line_ix {
# Cycle through the lines of file $filename and try matching them
# case-insensitively (modifier i) with the extended (modifier x) $regexp.
# For the first matching line, return the matched parts.
# If no line matches, return undef;
    my ($regexp, $filename) = @_;

    open(my $fh, "< $filename")
      or die "Cannot open $filename for reading: $!\n";
    while (defined (my $line = <$fh>)) {
        my @matches = ($line =~ /$regexp/ix);
        if (@matches) {
            close $fh or die "Cannot close $filename: $!\n";
            return @matches;
        }
    }

    close $fh or die "Cannot close $filename: $!\n";
    return undef;
}
# ---------------------------------------------------------------------- #
sub stash_time_series {
# Rename an existing data/timeseries.dat file to
# data/time_series.<timestring>
    my $tseries = "$data_dir/time_series.dat";
    if (-e $tseries) {
        my $stashed_series = "$data_dir/time_series." . timestr();
        rename $tseries, $stashed_series
          or die "Cannot rename $tseries to $stashed_series: $!\n";
    }
}
# ---------------------------------------------------------------------- #
sub get_lock {
    if (-e 'NEVERLOCK') {
        return;
    }

    if (-e $lockfile) {
        print "\n";
        print "getconf.csh: found LOCK file\n";
        print "(if it is left over from a crash, remove it manually: rm LOCK)\n";
        print "\n";
        print "Will *not* start in this directory, as the code may already ";
        print "be running.\n";
        print "Checking for NEWDIR file to tell us to run somewhere else:\n";
        print "[Not yet implemented]\n";
        die "\n";           # die(), not exit() or lockfile gets removed
    } else {
        touch($lockfile);
        $locked = 1;
    }
}
# ---------------------------------------------------------------------- #
sub clear_lock {
    if (-e $lockfile) {
        unlink $lockfile
          or warn "Cannot remove lock file $lockfile: $!\n";
    }
    $locked = 0;
}
# ---------------------------------------------------------------------- #
sub clear_error {
    if (-e $errorfile) {
        unlink $errorfile
          or warn "Cannot remove lock file $lockfile: $!\n";
    }
}
# ---------------------------------------------------------------------- #
sub timestr {
# Return date and time in a compact way to attach to file names
    return POSIX::strftime("%y%m%d.%H%M", localtime);
}
# ---------------------------------------------------------------------- #
sub touch {
# Create a file with current time stamp.
# Write $text to file if defined, otherwise write short note identifying
# this script.
    my ($filename, $text) = @_;

    open(my $fh, "> $filename")
      or die "Cannot open $filename for writing: $!\n";
    unless (defined($text)) {
        use POSIX qw(strftime);
        $text = "File: $filename\n"
          . "Generator: $cmdname\n"
          . "Time stamp: "
          . strftime("%a %Y-%m-%e %H:%M:%S", localtime())
          . "\n";
    }
    chomp $text;
    print $fh $text, "\n";
    close $fh or die "Cannot close file $filename\n";
}
# ---------------------------------------------------------------------- #
sub mention {
# Reference a variable without doing anything.
# Use this to suppress ``Name "Pencil::ConfigFinder::debug" used only
# once'' warning
    my @args = @_;
}
# ---------------------------------------------------------------------- #
sub printopts {
# Print command line options
    my $optsref = shift;
    my %options = %$optsref;
    foreach my $opt (keys(%options)) {
        print STDERR "\$options{$opt} = `$options{$opt}'\n";
    }
}
# ---------------------------------------------------------------------- #
sub usage {
# Extract description and usage information from this file's header.
    my $thisfile = __FILE__;
    local $/ = '';              # Read paragraphs
    open(FILE, "<$thisfile") or die "Cannot open $thisfile\n";
    while (<FILE>) {
        # Paragraph _must_ contain `Description:' or `Usage:'
        next unless /^\s*\#\s*(Description|Usage):/m;
        # Drop `Author:', etc. (anything before `Description:' or `Usage:')
        s/.*?\n(\s*\#\s*(Description|Usage):\s*\n.*)/$1/s;
        # Don't print comment sign:
        s/^\s*# ?//mg;
        last;                        # ignore body
    }
    return $_ or "<No usage information found>\n";
}
# ---------------------------------------------------------------------- #
sub version {
# Return SVN/CVS data and version info.
    my $doll='\$';              # Need this to trick SVN/CVS
    my $rev = '$Revision: 1.12 $';
    my $date = '$Date: 2008/07/07 21:37:16 $';
    $rev =~ s/${doll}Revision:\s*(\S+).*/$1/;
    $date =~ s/${doll}Date:\s*(\S+).*/$1/;

    return "$cmdname version $rev ($date)\n";
}
# ---------------------------------------------------------------------- #

END {
    clear_lock() if ($locked);
    unlink 'resubmit.log';
    unlink 'rs';
}

# End of file build
