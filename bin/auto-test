#!/bin/sh
#  -*-Perl-*-
#======================================================================#
# Run the right perl version:
if [ -x /usr/local/bin/perl ]; then
  perl=/usr/local/bin/perl
elif [ -x /usr/bin/perl ]; then
  perl=/usr/bin/perl
else
  perl=`which perl| sed 's/.*aliased to *//'`
fi

exec $perl -x -S $0 "$@"     # -x: start from the following line
#======================================================================#
#! /Good_Path/perl -w 
# line 17

# Name:   auto-test
# Author: wd (Wolfgang.Dobler@kis.uni-freiburg.de)
# Date:   12-Aug-2002
# CVS: $Id: auto-test,v 1.32 2003-07-20 06:49:19 brandenb Exp $
# Description:
#   Test compilation and results on a set of sample directories to
#   validate the pencil code. Uses Perl because I started to do this with
#   the Test/Test::Harness module and because we need to do pattern
#   matching to extract the relevant output lines.
# To Do:
# - Remove directory from /var/tmp when encountering Ctl-c
# - Investigate the return status after namelist error or similar

use strict;
use constant QUIET=>1;
use Cwd;
use POSIX qw(floor);
use Getopt::Long;
use vars qw{ %failed $ntests $test_status };

$ntests=0;

# ---------------------------------------------------------------------- #
# Test the following subdirs of samples/ :
my @sampdir = qw( conv-slab conv-slab-flat
                  helical-MHDturb interlocked-fluxrings mdwarf
                  1d-tests/sod_10);
# Test the following subdirs of runs/ :
my @runsdir = qw( forced/hydro1 radiation/solar1d4);
# ---------------------------------------------------------------------- #
## Override for testing:
#@sampdir = qw( conv-slab );
#@runsdir = qw(  );

my $tmpdir = "/var/tmp/pencil-tmp-$$";
my $cfloat = '([+-]?)(?=\d|\.\d)\d*(\.\d*)?([Ee]([+-]?\d+))?'; # regexp
                                                               # for C float
my $noheader = "Couldn't find header line";
my $res;
my ($t_comp,$t_start,$t_run,$t_res) = (1,1,1,1); # test everything by default
my (%opts);			# variables written by GetOptions
my $help = 0;
(my $cmdname = $0) =~ s{.*/}{};

my $usage =
"Usage:  $cmdname [options] [dir1 [dir2 [..]]]
  Test compilation and results on a set of sample directories (or on the
  list of directories given in the command line) to validate the pencil code.
  Uses Perl because we need to do pattern matching to extract the relevant
  output lines.
    If you don't have a data directory, $cmdname creates a link to
  $tmpdir -- both link and directory are removed after
  each run.
Options:
  -h,  --help           \tShow usage overview
  -v,  --version        \tPrint version number
  -C,  --clean          \tClean up (make cleann) before compiling
  -c,  --compile-only   \tTest compilation only
  -n,  --norun          \tTest compilation and starting only
  -t,  --time           \tPrint CPU time used
  -s,  --short          \tPrint short directory names only";

## Process command line options
eval {
    Getopt::Long::config("bundling"); # makes single-letter options case-sensitive
};
GetOptions(\%opts,
	   qw( -h   --help
	       -v   --version
	            --debug
	       -C   --clean
               -c   --compile-only
	       -n   --norun
	       -t   --time
	       -s   --short
                             ));

if ($opts{'h'} || $opts{'help'}) { $help=1; die "$usage\n"; }
if ($opts{'v'} || $opts{'version'}) {
    $help=1;
    die '$Id: auto-test,v 1.32 2003-07-20 06:49:19 brandenb Exp $ ' . "\n";
}
if ($opts{'c'} || $opts{'compile-only'}) { $t_start=$t_run=$t_res=0 };
if ($opts{'n'} || $opts{'norun'}) { $t_run=0 };
my $debug = (              $opts{'debug'} || 0);
my $short = ($opts{'s'} || $opts{'short'} || 0);
my $time  = ($opts{'t'} || $opts{'time'}  || 0);
my $clean = ($opts{'C'} || $opts{'clean'} || 0);

## Debugging output:
if ($debug) {
    eval("use Data::Dumper");	# Need eval here to calm down compiler
    print STDERR Dumper(\%opts);
    print STDERR
	"(\$t_comp,\$t_start,\$t_run,\$t_res)"
	. " = ($t_comp,$t_start,$t_run,$t_res)\n";
    print STDERR 
	"(\$debug,\$help,\$short)           "
	. " = ($debug,$help,$short)\n";
}

# $t_comp .. $t_res form a hierarchy: We can't test running without
# compiling and starting
$t_start &&= $t_comp;
$t_run &&= $t_start;
$t_res &&= $t_run;

# Prepend current directory if does not start with a `/'
my $cwd = `pwd`; chomp($cwd);
@ARGV = map { s{^(?!/)}{$cwd/}; $_ } @ARGV; # Make `.' and similar work

# Make sure we are in the top directory and have the right PATH
die "Need to set environment variable PENCIL_HOME\n" 
    unless (defined($ENV{PENCIL_HOME}));
my $topdir = "$ENV{PENCIL_HOME}";
chdir $topdir;
$ENV{PATH} .= ":$ENV{PENCIL_HOME}/bin";

# Autoflush stdout:
$| = 1;

if (@ARGV) {			# Process dirs given in cmd line
    for my $d (@ARGV) {
	test_rundir("$d");
    }
} else {			# No dirs in cmd line -> do standard program
    # Process dirs in samples/ directory
    for my $d (@sampdir) {
	test_rundir("$topdir/samples/$d");
    }
    # Process dirs in runs/ directory
    if (-d "$topdir/runs") {
	for my $d (@runsdir) {
	    test_rundir("$topdir/runs/$d");
	}
    } else {
	print "Not checking in $topdir/runs : no such directory\n";
    }
}

# ---------------------------------------------------------------------- #
sub my_ok {
# Similar to Test's and Test::Harness' ok() function: consider success if
# first two argumets are equal, otherwise report a problem and print the
# third argument (which should normally contain the output from the shell
# calls that we are normally testing here).
# Args #4 and #5 are the current run directory and the phase (compilation,
# starting, running) we are in.

    my $arg1 = shift;
    my $arg2 = shift;
    my $mesg = (shift || "<No diagnostics>"); 
    chomp($mesg);
    my $dir = shift;
    my $phase = shift;
    my $quiet = (shift || 0);

    # Allow for calls like `ok(0)' or `ok(1)':
    if (!defined($arg2)) {
	$arg2 = $arg1 ? $arg1 : 1;
    }
    if ($arg1 eq $arg2) {
	print "  ok\n" unless ($quiet);
    } else {
	print "  not ok:\n  $mesg\n";
	$test_status = 1;
	# report only first failure:
	$failed{$dir} = $phase unless defined($failed{$dir});
    }
}

sub test_shell_cmd {
    my $cmd = shift;
    my $dir = (shift || "<Unknown directory>");
    my $phase = (shift || "<Unkonwn phase>");
    my $quiet = (shift || 0);	# flag for suppressing the `ok'

    if ($debug) { print STDERR "Running `$cmd`" };
    my $res = (`$cmd 2>&1` || "Very BAD: `$cmd' returned undef");
    if ($debug) { print STDERR " ..done \n" };
    chomp($res);
    my_ok($?,0,$res,$dir,$phase,$quiet); # $? = 0 means success
    $res;			# Return output so we can analyze it if desired
}

sub test_compile {
# Test compilation only
    if ($t_comp) {
	my $dir = shift;
	print "    Compiling..         ";
	test_shell_cmd('setup-src',$dir,"setting up directory",QUIET);
	if ($clean) {
	    test_shell_cmd('cd src; make cleann',$dir,"cleaning up",QUIET);
	}
	test_shell_cmd('cd src; make',$dir,"compilation");
    }
}

sub test_start {
# Test starting only
    if ($t_start) {
	my $dir = shift;
	print "    Starting..          ";
	test_shell_cmd('start.csh',$dir,"starting");
    }
}

sub test_run {
# Test running only (does not analyze output, but returns it)
    if ($t_run) {
	my $dir = shift;
	print "    Running..           ";
	$res = test_shell_cmd('run.csh',$dir,"running");
    }
}

sub test_results {
# Analyze results from code
    if ($t_res) {
	my $dir = shift;
	my ($rdmsg,$diagn);
	print "    Validating results..";
#	print "    [Not yet implemented]";
	my @output = split(/[\n\r]+/,$res);
	my_ok(0,0,"",$dir,"results","quiet");
	my @foutput = extract_results(\@output); # filtered output
	if ($foutput[0] ne "$noheader") {
	    my @ref_output = read_lines("reference.out",$rdmsg);
	    if ($rdmsg) {
		print " [$rdmsg]\n";
	    } else {
		my $comp = compare_results(\@ref_output,\@foutput,$diagn);
		my_ok($comp,1,$diagn,$dir,"results");
	    }
	} else { # No header line found
	    my_ok(0,1,join("\n",@output),$dir,"results");
	}
    }
}

sub extract_results {
# Extract result lines (header line and numerical data) from the output of
# the code
    my $lineptr = shift;
    my @lines = @$lineptr;

    my $headerpat = '^-*\s*(-+[A-Za-z0-9_]+)+-*\s*$';
    my @results = ();
    my @labels = ();
    my $body = 0;		# true after header line
    my $ncols;

    line: foreach my $line (@lines) {
	unless ($body) {
	    # Before or at header line
	    next line unless ($line =~ /$headerpat/);
	    push @results, $line;
	    $body = 1;
	    @labels = grep { /\S/ } split(/-+/,$line); # ignore empty labels
	    $ncols = @labels;
	} else {
	    # After header line
	    next unless ($line =~ /^(\s+$cfloat){$ncols}\s*$/);
	    push @results, $line;
	}
    }
    if ($body) {
	@results;
    } else {
	($noheader);
    }
}

sub read_lines {
# Read file an return hash of non-empty lines
    my $file = shift;
    my @lines = ();
    my $msg = "";

    {
	local $/ = undef;	# read in whole file
	if (open (REF, "< $file")) {
	    @lines = grep { /\S/ } split(/[\n\r]+/,<REF>);
	    # Remove leading comment sign from header line:
	    $lines[0] =~ s/^(\s*)#/$1 /;
	} else {
	    $msg = "Couldn't open $file";
	}
    }
    $_[0] = $msg;
    @lines;
}

sub compare_results {
# Compare two arrays linewise; if all lines are the same, return 1; if
# not, return 0 and write report to third argument
    my $arr1 = shift;
    my $arr2 = shift;

    my @pref = ("< ", "> ", "  "); # prefixes to mark differing lines
    my $n1 = $#$arr1;
    my $n2 = $#$arr2;
    my $N = ($n2>$n1 ? $n2 : $n1);
    my $diagn = "";
    my $equal = 1;
    for my $i (0..$N) {
	my $line1 = ($$arr1[$i] || ""); chomp $line1;
	my $line2 = ($$arr2[$i] || ""); chomp $line2;
	if ($line1 ne $line2) {
	    $diagn .= $pref[0] . $line1 . "\n" if ($line1);
	    $diagn .= $pref[1] . $line2 . "\n" if ($line2);
	    $equal = 0;
	} else {
	    if ($i == 0) {	# Keep header line for easier reading
		$diagn .= $pref[2] . $line1 . "\n";
	    }
	}
    }
    $_[0] = $diagn;		# the remaining argument (was the third one)
    $equal;
}

sub test_rundir {
# Test compilation, starting, running and results
    my $dir = shift;
    my $created_datadir = 0;

    $test_status = 0;		#  so far, everything is OK

    # Go to directory and identify it
    if (! -d $dir) {
	print STDERR "No such directory: $dir\n";
	return;
    }
    chdir $dir;
    my $cwd = cwd();
    if ($short) { $cwd =~ s{.*pencil[^/]*/}{}i };
    print "\n", $cwd, ":\n";
    $ntests++;

    # Make sure we have everything we need
    if (! defined(-e 'src/run.f90')) { # has `setup-src' been run yet?
	my $res = `setup-src 2>&1`;
	if ($?) {
	    print "    Problems running setup-src:\n", $res;
	}
    }

    # Test compilation
    test_compile($dir);
    return if ($test_status);

    # Ensure we have a data directory and test starting and running
    return unless ($t_start);	# no need for a data directory unless we start
				# the code
    if (! -d 'data') {
	if (-l 'data') {
	    print "        data is file or empty link;\n"
		. "        removing and generating data -> $tmpdir\n";
	    system("rm", "data");
	}
	else
	{
	    print "        No data directory; generating data -> $tmpdir\n";
	}
	system("mkdir -p $tmpdir; ln -s $tmpdir data");
	$created_datadir = 1;
    }
    test_start($dir);
    goto cleanup if ($test_status);
    # we only get here if compiling and starting was OK
    test_run($dir);
    return if ($test_status);

    # need to check the output here..
    test_results($dir);

    # Clean up if necessary
  cleanup:
    if ($created_datadir) {
	system("rm", "data");
	system("rm", "-r", "$tmpdir");
    }
}

sub s_to_hms{
# Convert no. of seconds to [ddd][hh:]mm:ss string
    my $secs = shift;
    my $ss = $secs % 60;
    my $mm = floor($secs/60) % 60;
    my $hh = floor($secs/3600) % 24;
    my $dd = floor($secs/86400);

    my $string = sprintf("%02d:%02d", $mm,$ss);
    if ($hh) { $string = sprintf("%02d:", $hh) . $string };
    if ($dd) { $string = sprintf("%dd", $dd) . $string };

    $string;
}

END {
    if (!$help) {
	print "\n" . "-" x 70 . "\n";
	if (%failed) {
	    print "Failed ", scalar(keys %failed),
	      " test(s) out of $ntests:\n";
	    while (my ($dir,$phase) = each %failed) {
		print "  $dir ($phase)\n";
	    }
	} else {
	    if ($ntests == 1) { print "Test succeeded.\n" }
	    elsif ($ntests > 1) { print "All $ntests tests succeeded.\n" }
	}
	if ($time) {
	    my @t = times();
	    print "\nCPU time (including compilation): ",
	          s_to_hms($t[2]) . "u ",
                  s_to_hms($t[3]) . "s\n";
	}
    }
}

# End of file auto-test
