#!/usr/bin/perl
# Fortran coding style tester for the Pencil Code style.
# Checks currently only very basic things, like the indentation.
# Feel free to add more tests carefully.
# 17.11.2015, Bourdin.KIS: coded.
# $Id$

use strict;

# settings
my $indentation_str = "  ";
my $continuation_str = "    ";
my $auto_correct = 0; # enable with "= 1", if you like to overwrite your files with garbage! ;-)
my @trigger_indent = ("program", "module", "contains", "interface", "type", "subroutine", "function", "where", "do", "repeat", "if", "select");

# check filename
my $filename = $ARGV[0];
if (!$filename) { die ("Usage: ".$0." filename\n"); }
if (!-e $filename) { die ("No such file or directory (".$filename.")\n"); }
if (!-f $filename) { die ("Not a file (".$filename.")\n"); }

# initialize globals and scan file
my %state = ();
my @lines = [];
my $pos = 0;
my $num_warnings = 0;
my $num_fatals = 0;
my $indentation = length ($indentation_str);
my $continuation = length ($continuation_str);
my $num_trigger_indent = @trigger_indent;
scan_file ($filename);

print_warnings ();
exit (0);


sub scan_file {
	my ($file) = @_;

	# reset state
	$state{'indent'} = 0;
	$state{'indent_str'} = "";
	$state{'nesting'} = "";
	$state{'last_nesting'} = "";
	$state{'continuation'} = 0;
	$state{'multiline_if'} = 0;
	$state{'multiline_where'} = 0;
	$state{'else_branch'} = "";

	# read file
	my $num_lines = 0;
	open (FILE, "< ".$file);
	while (defined (my $line = <FILE>)) {
		$num_lines++;
		$line =~ s/\n$//s;
		$lines[$num_lines] = $line;
	}
	close (FILE);

	# parse and check file
	for ($pos = 1; $pos <= $num_lines; $pos++) {
		$_ = $lines[$pos];

		# white-spaces
		if (/\r$/s) {
			warning ("convert to 'unix EOL'-format");
			s/\r$//s;
		}
		if (/\r/s) {
			warning ("unallowed 'carriage-return' character");
			s/\r//gs;
		}
		if (/\f/s) {
			warning ("unallowed 'form-feed' character");
			s/\f//gs;
		}
		if (/\t/s) {
			warning ("unallowed 'tabulator' character");
			s/\t/${indentation_str}/gs;
		}
		if (/\s+$/s) {
			warning ("remove 'spaces' at end of line");
			s/\s*$//s;
		}

		# comments
		if (/^$/) {
			warning ("empty lines should have a '!' in front");
			$_ = "!";
			next;
		}
		if (/^(\s+)\!/s) {
			my $spaces = $1;
			my $num_spaces = length ($spaces);
			if (($num_spaces != $state{'indent'}) && ($num_spaces <= $state{'indent'}*2)) {
				warning ("comments start either at the beginning of a line or at the correct indentaion level");
				if (($num_spaces > $state{'indent'}*4/3) && ($num_spaces >= 4)) {
					$spaces = $state{'indent_str'};
				}
				else {
					$spaces = "";
				}
				s/^\s+\!/${spaces}\!/s;
			}
		}
		if (/^\s*\!/s) { next; }

		# indentation
		check_closed_nesting ($_);
		if ($state{'indent'} < 0) {
			fatal ("surplus 'end' => indentation became negative");
		}
		my $start_spaces = $state{'indent_str'};
		if ($state{'continuation'} > 0) { $start_spaces .= $continuation_str; }
		if (!/^${start_spaces}\S/s) {
			if (($state{'continuation'} > 0) && (/^${start_spaces}\s/s)) { ; }
			elsif (($state{'continuation'} <= $continuation) || (($state{'continuation'} >= $continuation*2) && (!/^${start_spaces}${continuation_str}\S/s))) {
				# print "NESTING:".$state{'nesting'}." LEVEL:".$state{'indent'}."\n";
				warning ("wrong indentation level");
				s/^\s*/${start_spaces}/s;
			}
		}
		check_new_nesting ($_);

		# multiple commands per line
		if (/\;/s) {
			warning ("possible multi-command line => better put one command per line");
		}

		# continuation
		if (/\&$/s) {
			$state{'continuation'} += $continuation;
		}
		else {
			$state{'continuation'} = 0;
		}

		# store auto-corrected line
		$lines[$pos] = $_;
	}

	$_ = join ("\n", @lines)."\n";

	# empty else-blocks
	while (/(^.*?\n)\s*else\n\s*end(?:\s*if)?(?:\s|\n)/is) {
		my $pre = $1;
		$pre =~ s/[^\n]+//gs;
		$pos = length ($pre);
		warning ("remove empty else-block");
		s/\n\s*else(\n\s*end(?:\s*if)?(?:\s|\n))/${1}/is;
	}

	if ($auto_correct) {
		# write auto-corrected file
		open (FILE, "> ".$file);
		print FILE $_;
		close (FILE);
	}
}

sub warning {
	my ($message) = @_;
	$num_warnings++;
	warn ("(L: ".$pos.") ".$message."\n");
}

sub print_warnings {
	if ($num_warnings > 0) { warn ("\n".$num_warnings." WARNINGS should be fixed.\n"); }
}

sub fatal {
	my ($message) = @_;
	$num_fatals++;
	warn ("(L: ".$pos.") FATAL: ".$message."\n");
	print_warnings;
	warn ("\n".$num_fatals." FATAL errors!\n");
	exit (1);
}

sub add_nesting {
	my ($nesting) = @_;
	$state{'nesting'} .= $nesting.'|';
	$state{'last_nesting'} = $nesting;
	$state{'indent'} += $indentation;
	$state{'indent_str'} .= $indentation_str;
}

sub remove_nesting {
	$state{'indent'} -= $indentation;
	$state{'indent_str'} =~ s/${indentation_str}$//s or fatal ("internal error while reducing the indentation string");
	$state{'last_nesting'} = "";
	if ($state{'nesting'} =~ /([^\|]+)\|$/s) { $state{'last_nesting'} = $1; }
}

sub check_new_nesting {
	my ($line) = @_;
	$_ = $line;
	s/\s*\!.*$//s;
	if ($state{'multiline_if'}) {
		$state{'multiline_if'} = 0;
		if (/\sthen$/is) { add_nesting ("if"); }
		if (/\&$/s) { $state{'multiline_if'} = 1; }
		return;
	}
	if ($state{'multiline_where'}) {
		$state{'multiline_where'} = 0;
		if (/\)$/is) { add_nesting ("where"); }
		if (/\&$/s) { $state{'multiline_where'} = 1; }
		return;
	}
	if ($state{'else_branch'}) {
		add_nesting ($state{'else_branch'});
		$state{'else_branch'} = "";
		return;
	}
	for (my $index = 0; $index < $num_trigger_indent; $index++) {
		my $trigger = $trigger_indent[$index];
		if (/^\s*${trigger}[^a-z0-9_'" ]/is) {
			warning ("space after '".$trigger."'-statement required");
			s/^(\s*${trigger})/${1} /s;
			$lines[$pos] =~ s/^(\s*${trigger})/${1} /s;
		}
		if ((/^\s*${trigger}\s/is) || (($trigger eq "contains") && (/^\s*${trigger}$/is))) {
			if (/\;/s) { fatal ("put each indentation-sensitive command in a separate line"); }
			if (($trigger eq "module") && (/^\s*module\s+procedure\s/is)) { next; }
			if ($trigger eq "contains") { $trigger = ""; }
			if (($trigger eq "type") && (/\s::\s/is)) { next; }
			if (($trigger eq "if") && (/\&$/s)) { $state{'multiline_if'} = 1; return; }
			if (($trigger eq "if") && (!/\sthen\s*$/is)) { next; }
			if (($trigger eq "where") && (/\&$/s)) { $state{'multiline_where'} = 1; return; }
			if (($trigger eq "where") && (!/\)$/is)) { next; }
			add_nesting ($trigger);
			return;
		}
	}
}

sub check_closed_nesting {
	my ($line) = @_;
	$_ = $line;
	s/\s*\!.*$//s;
	my $trigger = "";
	if (/^\s*end\s?(\S+)(?:\s+\S+)?$/is) {
		$trigger = $1;
		if ($state{'nesting'} !~ s/(^|\|)${trigger}(\|+)$/${1}${2}/is) {
			fatal ("misplaced 'end".$trigger."' => better use the pure 'end'-statement");
		}
	}
	elsif (/^\s*end(?:\s+\S+)?$/is) {
		if ($state{'nesting'} !~ s/(^|\|)[^\s\|]+(\|+)$/${1}${2}/s) { 
			fatal ("internal error while removing nesting");
		}
	}
	elsif (/^\s*else(.*?)$/is) {
		my $else = $1;
		my $type = $state{'last_nesting'};
		if ($else =~ /^\s+${type}/s) {
			warning ("better use 'else".$type."' instead of 'else ".$type."'");
			$else =~ s/^\s+//is;
			s/else\s+${type}/else${type}/is;
			$lines[$pos] =~ s/^(\s*else)\s+${type}/${1}${type}/is;
		}
		if ($else =~ /^${type}[^a-z0-9_ ]/is) {
			warning ("space after 'else".$type."'-statement required");
			$else =~ s/^${type}/${type} /is;
			s/^(\s*else${type})/${1} /s;
			$lines[$pos] =~ s/^(\s*else${type})/${1} /s;
		}
		if (($type eq "if") && ($else !~ /^$/s) && ($else !~ /\sthen/is)) {
			fatal ("must place 'then' after 'elseif'");
		}
		elsif (($else =~ /^${type}\s/is) || (($type eq "if") && ($else =~ /^$/is)) || (($type eq "where") && ($else =~ /^${type}$/is))) {
			if ($state{'nesting'} !~ s/(^|\|)${type}\|$/${1}\|/s) {
				fatal ("misplaced 'else".$trigger."'");
			}
			$state{'else_branch'} = $type;
		}
		else {
			# unrecognized "else...", might be something like "elset = 1"
			return;
		}
	}
	elsif (/^\s*case([^a-z0-9_].*?)$/is && ($state{'last_nesting'} eq "select")) {
		my $case = $1;
		my $type = $state{'last_nesting'};
		if ($case !~ /^\s/s) {
			warning ("space after 'case'-statement required");
			$case = " ".$case;
			s/^(\s*case)/${1} /is;
			$lines[$pos] =~ s/^(\s*case)/${1} /is;
		}
		if ($state{'nesting'} !~ s/(^|\|)${type}\|$/${1}\|/s) {
			fatal ("misplaced 'case'");
		}
		$state{'else_branch'} = $type;
	}
	else {
		# no end, nor else
		return;
	}
	if (($trigger eq "module") && ($state{'nesting'} =~ s/(^|\|)\|$/${1}/s)) { remove_nesting; }
	if ($state{'nesting'} =~ s/(^|\|)\|$/${1}/s) { remove_nesting; }
}

