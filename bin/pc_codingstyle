#!/usr/bin/perl
# Fortran coding style tester for the Pencil Code style.
# Checks currently only very basic things, like the indentation.
# Feel free to add more tests carefully.
# 17.11.2015, Bourdin.KIS: coded.
# $Id$

use strict;

# settings
my $indentation_str = "  ";
my $continuation_str = "    ";
my @trigger_indent = ("program", "module", "contains", "interface", "type", "subroutine", "function", "where", "do", "repeat", "if", "select");

# options (might become command-line arguments later)
my $picky = 1; # enable with "= 1", if you like punishment
my $auto_correct = 0; # enable with "= 1", if you like to overwrite your files with garbage! ;-)
my $verbose = 1; # "= 1" gives debug output, "= 2" even more

# check filename
my $filename = $ARGV[0];
if (!$filename) { die ("Usage: ".$0." filename\n"); }
if (!-e $filename) { die ("No such file or directory (".$filename.")\n"); }
if (!-f $filename) { die ("Not a file (".$filename.")\n"); }

# initialize globals and scan file
my %state = ();
my @lines = [];
my $pos = 0;
my $num_warnings = 0;
my $num_fatals = 0;
my $indentation = length ($indentation_str);
my $continuation = length ($continuation_str);
my $num_trigger_indent = @trigger_indent;
scan_file ($filename);

print_num_warnings ();
exit (0);


sub scan_file {
	my ($file) = @_;

	# reset state
	$state{'indent'} = 0;
	$state{'indent_str'} = "";
	$state{'nesting'} = "";
	$state{'last_nesting'} = "";
	$state{'continuation'} = 0;
	$state{'multiline_if'} = 0;
	$state{'multiline_where'} = 0;
	$state{'else_branch'} = "";
	$state{'eol_comment'} = 0;

	# read file
	my $num_lines = 0;
	open (FILE, "< ".$file);
	while (defined (my $line = <FILE>)) {
		$num_lines++;
		$line =~ s/\n$//s;
		$lines[$num_lines] = $line;
	}
	close (FILE);

	# parse and check file
	for ($pos = 1; $pos <= $num_lines; $pos++) {
		$_ = $lines[$pos];

		# white-spaces
		if (/\r$/s) {
			warning ("convert to 'unix EOL'-format");
			s/\r$//s;
		}
		if (/\r/s) {
			warning ("unallowed 'carriage-return' character");
			s/\r//gs;
		}
		if (/\f/s) {
			warning ("unallowed 'form-feed' character");
			s/\f//gs;
		}
		if (/\t/s) {
			warning ("unallowed 'tabulator' character");
			s/\t/${indentation_str}/gs;
		}
		if (/\s+$/s) {
			warning ("remove 'spaces' at end of line");
			s/\s*$//s;
		}
		if (/ +,/s) {
			warning ("remove 'spaces' before a comma");
			s/ +,/,/s;
		}

		# comments
		if (/^$/) {
			warning ("empty lines should have a '!' in front");
			$_ = "!";
		}
		my $no_strings = cut_strings ($_);
		if ($no_strings =~ /^( +)\!/s) {
			my $spaces = $1;
			my $num_spaces = length ($spaces);
			if ($num_spaces != $state{'indent'}) {
				if (($state{'eol_comment'} > 0) && ($num_spaces > $state{'indent'})) {
					# multi-line comment block with extra indentation
					warning ("no extra indentation for multi-line comment blocks");
				}
				else {
					warning ("comments start either at the beginning of a line or at the correct indentaion level");
					if (($num_spaces > $state{'indent'}*4/3) && ($num_spaces >= 4)) {
						$spaces = $state{'indent_str'};
					}
					else {
						$spaces = "";
					}
					s/^ +\!/${spaces}\!/s;
				}
			}
		}
		if (/^ *\!/s) {
			$lines[$pos] = $_;
			next;
		}
		if ($no_strings =~ /\S *\!/s) {
			# comment at end of line
			picky_warning ("comments start either at the beginning of a line or at the correct indentaion level");
			$state{'eol_comment'} = 1;
		}
		else {
			$state{'eol_comment'} = 0;
		}

		# jumping around
		if (/, *end *=/s) {
			accumulative_fatal ("'end=' is forbidden => use 'iostat=' instead, a conditional 'exit' may help in loops");
		}

		# format strings
		if (/, *fmt *= *(\d+)/s) {
			accumulative_fatal ("'fmt=".$1."' is forbidden => better move the format string directly there");
		}

		# indentation
		check_closed_nesting ($_);
		if ($state{'indent'} < 0) {
			fatal ("surplus 'end' => indentation became negative");
		}
		my $start_spaces = $state{'indent_str'};
		if ($state{'continuation'} > 0) { $start_spaces .= $continuation_str; }
		if (!/^${start_spaces}\S/s) {
			if (($state{'continuation'} <= $continuation) || (($state{'continuation'} >= $continuation*2) && (!/^${start_spaces}${continuation_str}\S/s))) {
				if ($verbose) { print "NESTING:".$state{'nesting'}." INDENT:".$state{'indent'}."\n"; }
				die ($pos."wrong indentation level");
				s/^ */${start_spaces}/s;
			}
		}
		check_new_nesting ($_);

		# multiple commands per line
		if (/\;/s) {
			warning ("possible multi-command line => better put one command per line");
		}

		# continuation
		if (/\&$/s) {
			$state{'continuation'} += $continuation;
		}
		else {
			$state{'continuation'} = 0;
		}

		# store auto-corrected line
		$lines[$pos] = $_;
	}

	$_ = join ("\n", @lines)."\n";

	# empty else-blocks
	while (/(^.*?\n) *else(|where)(\n\![^\n]*)*\n *end *(|if|where)(?: |\n)/is) {
		my $pre = $1;
		my $type = $2;
		my $empty = $3;
		my $closing = $4;
		$pre =~ s/[^\n]+//gs;
		$pos = length ($pre);
		if ($type && (lc ($closing) ne lc ($type))) {
			$empty =~ s/[^\n]+//gs;
			$pos += length ($empty) + 1;
			fatal ("misplaced 'end".$closing."' after empty 'else".$type."'-block => better use the pure 'end'-statement");
		}
		warning ("remove empty 'else".$type."'-block");
		s/\n *else${type}(?:\n\![^\n]*)*(\n *end *${closing}(?: |\n))/${1}/is;
	}

	if ($auto_correct) {
		# write auto-corrected file
		open (FILE, "> ".$file);
		print FILE $_;
		close (FILE);
	}
}

sub cut_strings {
	my ($line) = @_;
	while ($line =~ /^(.*?)(['"])(.*)$/s) {
		my $pre = $1;
		my $type = $2;
		my $post = $3;
		if ($pre =~ /\!/s) { return ($line); }
		while ($post =~ /^(.*?)${type}(.*)$/s) {
			my $string = $1;
			my $rest = $2;
			$string =~ s/\\\\//gs;
			if ($string !~ s/\\$//s) {
				my $type_str = "";
				if ($type eq '\'') { $type_str = "apostroph"; }
				if ($type eq '"') { $type_str = "quote"; }
				$line = $pre."<type-".$type_str."><type-".$type_str.">".$rest;
				last;
			}
			$post = $string.$rest;
		}
	}
	$line =~ s/<type-quote>/"/gis;
	$line =~ s/<type-apostroph>/'/gis;
	return ($line);
}

sub picky_warning {
	my ($message) = @_;
	if (!$picky) { return; }
	warning ("picky: ".$message);
}

sub warning {
	my ($message) = @_;
	print_warning ($message);
	if ($num_fatals > 0) { perish (); }
}

sub print_warning {
	my ($message) = @_;
	$num_warnings++;
	warn ("[".$pos."] ".$message."\n");
}

sub print_num_warnings {
	if ($num_warnings > 0) { warn ("\n".$num_warnings." STYLE BREAKS should be fixed.\n"); }
}

sub accumulative_fatal {
	my ($message) = @_;
	$num_fatals++;
	print_warning ("FATAL: ".$message);
}

sub fatal {
	my ($message) = @_;
	$num_fatals++;
	warning ("FATAL: ".$message);
	perish ();
}

sub perish {
	print_num_warnings;
	warn ($num_fatals." of them were FATAL errors!\n");
	exit (1);
}

sub add_nesting {
	my ($nesting) = @_;
	if ($verbose >= 2) { warn ("[$pos] ADD: ".$nesting."\n"); }
	$state{'nesting'} .= $nesting.'|';
	$state{'last_nesting'} = $nesting;
	$state{'indent'} += $indentation;
	$state{'indent_str'} .= $indentation_str;
}

sub remove_nesting {
	if ($verbose >= 2) { warn ("[$pos] REMOVE: ".$state{'last_nesting'}."\n"); }
	$state{'indent'} -= $indentation;
	$state{'indent_str'} =~ s/${indentation_str}$//s or fatal ("internal error while reducing the indentation string");
	$state{'last_nesting'} = "";
	if ($state{'nesting'} =~ /([^\|]+)\|$/s) { $state{'last_nesting'} = $1; }
}

sub check_new_nesting {
	my ($line) = @_;
	if ($state{'multiline_if'}) {
		$state{'multiline_if'} = 0;
		if ($line =~ / then$/is) { add_nesting ("if"); }
		if ($line =~ /\&$/s) { $state{'multiline_if'} = 1; }
		return;
	}
	if ($state{'multiline_where'}) {
		$state{'multiline_where'} = 0;
		if ($line =~ /\)$/is) { add_nesting ("where"); }
		if ($line =~ /\&$/s) { $state{'multiline_where'} = 1; }
		return;
	}
	if ($state{'else_branch'}) {
		add_nesting ($state{'else_branch'});
		$state{'else_branch'} = "";
		return;
	}
	for (my $index = 0; $index < $num_trigger_indent; $index++) {
		my $trigger = $trigger_indent[$index];
		if ($trigger eq "contains") {
			if ($line =~ /^( *)contains$/is) {
				add_nesting ("");
				return;
			}
		}
		if ($line =~ /^ *${trigger}[^a-z0-9_'" ]/is) {
			warning ("space after '".$trigger."'-statement required");
			$line =~ s/^( *${trigger})/${1} /s;
			$lines[$pos] =~ s/^( *${trigger})/${1} /s;
		}
		if ($trigger eq "function") {
			if ($line =~ s/^( *)((?:integer|real|logical|long|double).*?) +function /${1}function /is) {
				picky_warning ("data type '".$2."' belongs inside the 'function' block");
			}
		}
		if ($line =~ /^ *${trigger} /is) {
			if ($line =~ /\;/s) { fatal ("put each indentation-sensitive command in a separate line"); }
			if (($trigger eq "module") && ($line =~ /^ *module +procedure /is)) { next; }
			if (($trigger eq "type") && ($line =~ /::/is)) { next; }
			if (($trigger eq "if") && ($line =~ /\&$/s)) { $state{'multiline_if'} = 1; return; }
			if (($trigger eq "if") && ($line !~ / then *$/is)) { next; }
			if (($trigger eq "where") && ($line =~ /\&$/s)) { $state{'multiline_where'} = 1; return; }
			if (($trigger eq "where") && ($line !~ /\)$/is)) { next; }
			add_nesting ($trigger);
			return;
		}
	}
}

sub check_closed_nesting {
	my ($line) = @_;
	my $trigger = "";
	if ($line =~ /^ *end ?(\S+)(?: +\S+)?$/is) {
		$trigger = $1;
		if ($state{'nesting'} !~ s/(^|\|)${trigger}(\|+)$/${1}${2}/is) {
			if ($verbose) { warn ("NESTING:".$state{'nesting'}." TRIGGER:".$trigger."\n"); }
			fatal ("misplaced 'end".$trigger."' => better use the pure 'end'-statement");
		}
	}
	elsif ($line =~ /^ *end(?: +\S+)?$/is) {
		if ($state{'nesting'} !~ s/(^|\|)[^ \|]+(\|+)$/${1}${2}/s) { 
			fatal ("internal error while removing nesting");
		}
	}
	elsif ($line =~ /^ *else(.*?)$/is) {
		my $else = $1;
		my $type = $state{'last_nesting'};
		if ($else =~ /^ +${type}/s) {
			warning ("better use 'else".$type."' instead of 'else ".$type."'");
			$else =~ s/^ +//is;
			$line =~ s/^( *else) +${type}/${1}${type}/is;
			$lines[$pos] = s/^( *else) +${type}/${1}${type}/is;
		}
		if ($else =~ /^${type}[^a-z0-9_ ]/is) {
			warning ("space after 'else".$type."'-statement required");
			$else =~ s/^${type}/${type} /is;
			$line =~ s/^( *else${type})/${1} /s;
			$lines[$pos] = s/^( *else${type})/${1} /s;
		}
		if (($type eq "if") && ($else !~ /^$/s) && ($else !~ /\&$/s) && ($else !~ / then/is)) {
			# TODO: handle multi-line else-blocks correctly, currentyl just ignored
			fatal ("must place 'then' after 'elseif'");
		}
		elsif (($else =~ /^${type} /is) || (($type eq "if") && ($else =~ /^$/is)) || (($type eq "where") && ($else =~ /^${type}$/is))) {
			if ($state{'nesting'} !~ s/(^|\|)${type}\|$/${1}\|/s) {
				if ($verbose) { warn ("NESTING:".$state{'nesting'}." TYPE:".$type."\n"); }
				fatal ("misplaced 'else".$trigger."'");
			}
			$state{'else_branch'} = $type;
		}
		else {
			# unrecognized "else...", might be something like "elset = 1"
			return;
		}
	}
	elsif ($line =~ /^ *case([^a-z0-9_].*?)$/is && ($state{'last_nesting'} eq "select")) {
		my $case = $1;
		my $type = $state{'last_nesting'};
		if ($case !~ /^ /s) {
			warning ("space after 'case'-statement required");
			$case = " ".$case;
			$line =~ s/^( *case)/${1} /is;
			$lines[$pos] = s/^( *case)/${1} /is;
		}
		if ($state{'nesting'} !~ s/(^|\|)${type}\|$/${1}\|/s) {
			if ($verbose) { warn ("NESTING:".$state{'nesting'}." TYPE:".$type."\n"); }
			fatal ("misplaced 'case'");
		}
		$state{'else_branch'} = $type;
	}
	else {
		# no end, nor else
		return;
	}
	if (($trigger eq "module") && ($state{'nesting'} =~ s/(^|\|)\|$/${1}/s)) { remove_nesting; }
	if ($state{'nesting'} =~ s/(^|\|)\|$/${1}/s) { remove_nesting; }
}

