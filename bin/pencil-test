#!/bin/sh
# -*-perl-*-
#======================================================================#
# Run the right perl version:
if [ -x /usr/local/bin/perl ]; then
  perl=/usr/local/bin/perl
elif [ -x /usr/bin/perl ]; then
  perl=/usr/bin/perl
else
  perl=`which perl| sed 's/.*aliased to *//'`
fi

exec $perl -x -S $0 "$@"     # -x: start from the following line
#======================================================================#
#! /Good_Path/perl -w
# line 17
#
# Name:   pencil-test
# Author: wd (Wolfgang.Dobler@kis.uni-freiburg.de)
# $Date: 2005-07-06 07:50:23 $
# $Revision: 1.21 $
# Description:
#   Run the pencil code's auto-test on some remote host(s) and wrap
#   results in HTML if required. Can be used from crontab.
# Usage:
#   pencil-test [-H] [-u] [-c] [-m <emaillist>] host1 [host2 [host3 ..]]
# Options:
#   -h, --help             -- Help
#   -H, --html             -- Write output as elementary HTML (mostly <pre>)
#   -u, --update           -- `cvs update' before compiling
#   -U, --up-d-samples     -- `cvs update; cvs update -d samples'
#                              before compiling
#   -c, --clean            -- `make cleann' before compiling
#   -N <N>, --nice=<N>     -- Run tests with nice value of <N>
#   -p <PP>,
#       --postproc=<PP>    -- Use postprocessor <PP> for output from make
#   -m <emaillist>,
#       --mail=<emaillist> -- Specify who to send mail to if tests fail
#   -M <mailer>,
#      --Mailer=<mailer>   -- Specify e-mail program to use
# Email list syntax:
#   -m '{-:fluxrings},defaulty@any.where,nosy@some.where{+:fluxrings,+:rad1},ignorant@else.where{-:hydro.*}'
#   will not send mail if `interlocked-fluxrings' fails -- except for Nosy
#   who explicitly requested this. Ignorant will not get emails if only `hydro1'
#   or `hydrogen-bond' fail. Note that the patterns are anchored at the end,
#   but not at the beginning.
# Crontab entry:
#   05 01 * * *     $HOME/bin/pencil-test -HU -N 15 -m '{-:solar1d4},email1@domain1,email2@domain2' kabul > $HOME/public_html/pencil-code/tests/kabul.html

use strict;
use Getopt::Long;

my (%opts);			# Variables written by GetOptions
my (%emails,%pos,%neg,%sendmailto); # Info on mailing if tests fail

## Process command line
eval {
    Getopt::Long::config("bundling");
};
GetOptions(\%opts,
	   qw( -h   --help
	       -H   --html
	       -u   --update
	       -U   --up-d-samples
	       -c   --clean
	       -N=s --nice=s
	       -m=s --mail=s
	       -M=s --Mailer=s
	       -p=s --postproc=s
	            --tag-stable=s
	            --tag-broken=s
	            --debug
	       ));
die usage() if ($opts{'h'} || $opts{'help'}     || @ARGV < 1);
my $debug      = (              $opts{'debug'}      || 0);
my $html       = ($opts{'H'} || $opts{'html'}       || 0);
my $clean      = ($opts{'c'} || $opts{'clean'}      || 0);
my $nice       = ($opts{'N'} || $opts{'nice'}       || 0);
my $update     = ($opts{'u'} || $opts{'update'}     || 0);
my $UPDATE     = ($opts{'U'} || $opts{'UPDATE'}     || 0);
my $tag_stable = (              $opts{'tag-stable'} || 0);
my $tag_broken = (              $opts{'tag-broken'} || 0);
if ($UPDATE) { $update=1 };
my $emails     = ($opts{'m'} || $opts{'mail'}       || '');
my $mailer     = ($opts{'M'} || $opts{'Mailer'}     || '');
my $postproc   = ($opts{'p'} || $opts{'postproc'}   || '');

## Print header
my $date = scalar localtime();
if ($html) {
    print <<"END_HEAD";
<html>
<head></head>
<body>

$date
<p>
END_HEAD
} else {
    print "$date\n\n";
}

## Run test(s)
my $first = 1;
my $t0 = time();
foreach my $host (@ARGV) {
    # Identify host
    my ($shost) = ($host =~ /([^.]*)/); # host name sans domain
    $shost = "\u$shost";
    if ($html) {
	unless ($first) { print "</pre>\n<p>\n<hr>\n<p>\n" };
	print "<h2>$shost:</h2>\n\n<pre>\n";
    } else {
	unless ($first) { print "\n\n" };
	print "  $host:\n================\n";
    }
    # Construct and execute remote command
    my @cmd = ("ssh", "-n", "$host");
    my $remcmd = 'cd $PENCIL_HOME';
    if ($update)   { $remcmd .= "; cvs update >& /dev/null" };
    if ($UPDATE)   { $remcmd .= "; cvs update -d samples >& /dev/null" };
    $remcmd .= "; ./bin/auto-test -s -t";
    if ($clean)    { $remcmd .= " --clean" };
    if ($nice)     { $remcmd .= " --nice=$nice" };
    if ($postproc) { $remcmd .= " --postproc=\"$postproc\"" };
#    push @cmd, $remcmd;
#    system("@cmd |");
    if ($debug) { print STDERR "open(POUT, \"@cmd '$remcmd' |\"\n" };
    open(POUT, "@cmd '$remcmd' |");
#    print "<",join("> <",@cmd,">\n");
#    print "<@cmd'>\n");
    my ($line,$result);
    while (defined($line=<POUT>)) {
	print $line;
	$result .= $line;
    }
    close(POUT);
    # Put tag on files if auto-test breaks
    tag_breakage_on_error($result,$host) if ($tag_broken);
    tag_stable_on_success($result,$host) if ($tag_stable);
    # Send emails if necessary
    notify_on_error($result,$shost);

   $first = 0;
}

my $t1 = time();

## Print footer

# Better print CPU time via auto-test than wall-clock time
# if ($html) { print "\n<p>\n" };
# print "Wall clock time: ", $t1-$t0, "s\n";

$date = scalar localtime();
if ($html) {
    print <<"END_FOOT";
<p>
$date
</pre>
</body>
</html>
END_FOOT
}

# ---------------------------------------------------------------------- #
sub usage {
# Extract description and usage information from this file's header.
    my $thisfile = __FILE__;
    local $/ = '';              # Read paragraphs
    open(FILE, "<$thisfile") or die "Cannot open $thisfile\n";
    while (<FILE>) {
        next unless /^\s*#\s*Usage:/m; # Paragraph _must_ contain `Usage:'
        # Drop `Author:', etc:
        s/.*?\n(\s*\#\s*(Description|Usage):\s*\n.*)/$1/s;
        # Don't print comment sign:
        s/^\s*\# ?//mg;
        last;
    }
    $_;
}
# ---------------------------------------------------------------------- #
sub tag_stable_on_success{
## Put tag on files of auto-test succeeds
    my $result = (shift || '');
    my $host  = (shift || '');
    my $cvscmd;

    return if ($result =~ /^Failed ([0-9]+) test/m);

    $cvscmd=        "ssh -n $host 'cd \$PENCIL_HOME;";
    $cvscmd=$cvscmd."cvs -Q tag -d ".$tag_broken." src bin > /dev/null;" if ($tag_broken);
    $cvscmd=$cvscmd."cvs -Q tag -F ".$tag_stable." src bin > /dev/null";
    $cvscmd=$cvscmd."'";
    system($cvscmd);
}
# ---------------------------------------------------------------------- #
sub tag_breakage_on_error{
## Put tag on files if auto-test breaks (only first break)
    my $result = (shift || '');
    my $host  = (shift || '');
    my $cvscmd;
    if ($result =~ /^Failed ([0-9]+) test/m) {
# We only want to mark the first breakage... So check it isn't already tagged.
      my $hastag="ssh -n $host 'cd \$PENCIL_HOME; cvs log -h Makefile.src'";
      return if ($hastag =~ /$tag_broken/);
# If we haven't already tagged it... Do so now.
      $cvscmd=        "ssh -n $host 'cd \$PENCIL_HOME;";
      $cvscmd=$cvscmd."cvs -Q tag -F ".$tag_broken." src bin > /dev/null;";
      $cvscmd=$cvscmd."'";
      system($cvscmd);
    }
}
# ---------------------------------------------------------------------- #
sub notify_on_error{
## Check for errors and send emails
    my $result = (shift || '');
    my $host  = (shift || '');
    if ($emails && ($result =~ /^Failed ([0-9]+) test/m)) {
	my $nerrors = $1;
	if ($debug) { print STDERR "Checking who to alert by email\n" };
	parse_emails($emails);
	# Analyse
	my ($main,$summary) = split(/^----*\s?\n(?=Failed)/m,$result);
	if (defined($summary)) {
	    # Extract list of failed directories
	    my @failures = split(/\n/,$summary);
	    ($nerrors) = ($failures[0] =~ /Failed ([0-9]+) test/);
	    @failures = grep /^\s*\S+\s\(.*\)\s*$/, @failures;
	    @failures = map { $_ =~ s/^\s*(\S*).*/$1/; $_ } @failures;
	    foreach my $address (keys %emails) {
		foreach my $fail (@failures) {
		    my $def_matches = ! any_match($fail,$neg{''});
		    my $pos_matches = any_match($fail,$pos{$address});
		    my $neg_matches = any_match($fail,$neg{$address});
		    if (($def_matches || $pos_matches) && ! $neg_matches) {
			if ($debug) { 
			    print STDERR "...", substr($fail,-15,15),
			      ": \$sendmailto{$address}++\n";
			}
			$sendmailto{$address}++;
		    }
		}
	    }
	    foreach my $address (keys %sendmailto) {
		send_mail($address,$nerrors,$host,$summary,$main,$mailer);
	    }
	} else {
	    warn "Can't split result string --- strange";
	}
    }
}
# ---------------------------------------------------------------------- #
sub parse_emails {
# Parse the email list into hashes
    my $emaillist = shift;
    my ($entry,$address,$spec);
    while ($emaillist) {
	$emaillist =~ /^([^\}\{,]*(?:\{[^\}]*\})?),?(.*)/
	  or warn "Cannot parse email list <$emaillist>\n";
	($entry,$emaillist) = ($1,$2);
	($address,$spec) = ($entry =~ /([^\}\{]*)\{?([^\}]*)\}?/);
	$emails{$address}++ if ($address =~ /\S/);
	foreach my $sp (split(/,/,$spec)) {
	    if ($sp =~ /^\-:(.*)/) {
		push @{$neg{$address}}, $1
#		push @{$neg{$1}}, $address;
	    } elsif ($sp =~ /^\+:(.*)/) {
		push @{$pos{$address}}, $1
#		push @{$pos{$1}}, $address;
	    } else {
		warn "Strange specification: <$spec>\n";
	    }
	}
    }
}
# ---------------------------------------------------------------------- #
sub any_match {
# Match a string against a list of patterns
    my $string = shift;
    my $pattern_pointer = shift;
    my @patterns = ();

    if (ref($pattern_pointer) eq 'ARRAY') {
	@patterns = @{$pattern_pointer}
    };

    foreach my $patt (@patterns) {
        if ($string =~ /$patt$/) { return 1; }
    }
    return 0;
}
# ---------------------------------------------------------------------- #
sub send_mail {
# Send an email to the given address
    my $address = shift;
    my $nerrors = shift;
    my $host    = shift;
    my $text1   = shift;
    my $text2   = shift;
    my $mailer  = shift;
 
    if (!$mailer) {
      if (in_PATH("mailx")) {
      $mailer = "mailx";
      } else {
      $mailer = "mail";
      }
    }

    my $plurals = ($nerrors<=1 ? '' : 's');
    my $cmdline = 
      "$mailer "
      . "-s '$nerrors error$plurals from pencil-code autotest on $host' "
      . "$address";
    if ($debug) { print STDERR "$cmdline\n" };
    open (MAIL, "| $cmdline");
    print MAIL "$text1\n";
    print MAIL "-" x 70, "\n";
    print MAIL "$text2\n";
    close MAIL;
}
# --------------------------------------------------------------------- #
sub in_PATH {
# Check whether an executable is available in the execution PATH
    my $file = shift;
    my $path;
    foreach $path (split(/:/,$ENV{PATH})) {
        if (-x "$path/$file") { return 1; }
    }
    return 0;
}
# ---------------------------------------------------------------------- #

# End of file pencil-test
