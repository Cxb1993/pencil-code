#!/bin/sh
# -*-perl-*-
# ====================================================================== #
# Run the right perl version:
if [ -x /usr/local/bin/perl ]; then
  perl=/usr/local/bin/perl
elif [ -x /usr/bin/perl ]; then
  perl=/usr/bin/perl
else
  perl=`which perl| sed 's/.*aliased to *//'`
fi

exec $perl -x -S $0 "$@"     # -x: start from the following line
# ====================================================================== #
#! /Good_Path/perl -w
# line 17
#
# Name:   pencil-test
# Author: wd (Wolfgang.Dobler@kis.uni-freiburg.de)
# $Date: 2008-07-11 05:02:53 $
# $Revision: 1.40 $
# Description:
#   Run the pencil code's auto-test on some remote host(s) and wrap
#   results in HTML if required. Can be used from crontab.
# Usage:
#   pencil-test [options] host1 [host2 [host3 ..]]
#   pencil-test -l [options]
# Options:
#   -h, --help                -- Help
#   -l, --local               -- Run on the local host
#   -H, --html                -- Write output as elementary HTML (mostly <pre>)
#   -X, --xml                 -- Write output as XML
#   -u, --update              -- `svn update' before compiling
#   -U, --up-samples          -- `svn update; svn update samples'
#                                before compiling
#   -r, --reload              -- Do `touch RELOAD' after every time step
#   -s, --short               -- Use short directory names
#   -c, --clean               -- `make cleann' before compiling
#   -D <DIR>,
#       --pencil-home=<DIR>   -- set PENCIL_HOME directory to DIR
#   -N <N>, --nice=<N>        -- Run tests with nice value of <N>
#   -i <file>,
#       --infofile=<file>     -- After last test, print content of <file>
#   -m <emaillist>,
#       --mail=<emaillist>    -- Specify who to send mail to if tests fail
#   -M <mailer>,
#      --Mailer=<mailer>      -- Specify e-mail program to use
#   -p <PP>,
#       --postproc=<PP>       -- Use postprocessor <PP> for output from make
#   -T <file>,
#       --timings-file=<file> -- Append timings to <file>
# Email list syntax:
#   -m '{-:fluxrings},defaulty@any.where,nosy@some.where{+:fluxrings,+:rad1},ignorant@else.where{-:hydro.*}'
#   will not send mail if `interlocked-fluxrings' fails -- except for Nosy
#   who explicitly requested this. Ignorant will not get emails if only `hydro1'
#   or `hydrogen-bond' fail. Note that the patterns are anchored at the end,
#   but not at the beginning.
# Crontab entry:
#   30 02 * * *  $HOME/f90/pencil-auto-test/bin/pencil-test -D /home/wdobler/f90/pencil-auto-test -N15 -Uc -rs -T $HOME/public_html/pencil-code/tests/g95_debug_timings.txt -Hm wdobler@gmail.com norlx50 > $HOME/public_html/pencil-code/tests/g95_debug.html

use strict;
use Getopt::Long;
use constant SUCCESS     => 1;  # for writing `return 

my (%opts);			# Variables written by GetOptions
my (%emails,%pos,%neg,%sendmailto); # Info on mailing if tests fail

## Process command line
eval {
    Getopt::Long::config("bundling");
};
GetOptions(\%opts,
	   qw( -h   --help
	            --debug
	       -v   --version
	       -l   --local
	       -H   --html
	       -X   --xml
	       -u   --update
	       -U   --up-samples
	       -r   --reload
	       -s   --short
	       -c   --clean
	       -D=s --pencil-home=s
	       -N=s --nice=s
               -i=s --infofile=s
	       -m=s --mail=s
	       -M=s --Mailer=s
	       -p=s --postproc=s
               -T=s --timings-file=s
	            --tag-stable=s
	            --tag-broken=s
	       )) or die "$!\n";
die '$Id$ ' . "\n"
            if    ($opts{'v'} || $opts{'version'});
die usage() if    ($opts{'h'} || $opts{'help'});
my $debug       = (              $opts{'debug'}       || 0 );
my $html        = ($opts{'H'} || $opts{'html'}        || 0 );
my $local       = ($opts{'l'} || $opts{'local'}       || 0 );
my $clean       = ($opts{'c'} || $opts{'clean'}       || 0 );
my $pencil_home = ($opts{'D'} || $opts{'pencil-home'} || '$PENCIL_HOME' );
my $nice        = ($opts{'N'} || $opts{'nice'}        || 0 );
my $infofile    = ($opts{'i'} || $opts{'infofile'}    || '' );
my $update      = ($opts{'u'} || $opts{'update'}      || 0 );
my $UPDATE      = ($opts{'U'} || $opts{'up-samples'}  || 0 );
my $reload      = ($opts{'r'} || $opts{'reload'}      || 0 );
my $short       = ($opts{'s'} || $opts{'short'}       || 0 );
my $tag_stable  = (              $opts{'tag-stable'}  || 0 );
my $tag_broken  = (              $opts{'tag-broken'}  || 0 );
if ($UPDATE) { $update=1 };
my $emails      = ($opts{'m'} || $opts{'mail'}        || '');
my $mailer      = ($opts{'M'} || $opts{'Mailer'}      || '');
my $postproc    = ($opts{'p'} || $opts{'postproc'}    || '');
my $timingsfile = ($opts{'T'} || $opts{'timings-file'}|| '');
my $with_xml    = ($opts{'x'} || $opts{'xml'}         || '');

my $blurb =
  "[This message was automatically generated by the `pencil-test' script]\n";
my ($xml);

# Too few or too many arguments?
if ($local) {
    die "No host arguments allowed with -l option.\n" if (@ARGV);
} else {
    die usage() unless (@ARGV);
}


print_header();

## Run test(s)
my $first = 1;
if ($local) {
    run_tests_on(`hostname`);
} else {
    foreach my $host (@ARGV) {
        run_tests_on($host)
    }
}

print_footer();

# ====================================================================== #

sub run_tests_on {
# Run auto tests remotely (unless $local is true) on the given host
    my ($host) = @_;
    chomp $host;

    print STDERR "run_test_on($host)" if ($debug);

    my ($shost) = ($host =~ /([^.]*)/); # host name sans domain
    $shost = "\u$shost";

    if ($html) {
	unless ($first) { print "</pre>\n<p>\n<hr>\n<p>\n" };
	print "<h2>$shost:</h2>\n\n<pre>\n";
    } else {
	unless ($first) { print "\n\n" };
	print "  $host:\n================\n";
    }

    ## Construct and execute remote command
    my @cmd;
    if ($local) {
        @cmd = ("sh", "-c");
    } else {
        @cmd = ("ssh", "-x", "-n", "$host");
    }
    my $remcmd = build_remote_cmd();

    if ($debug) { print STDERR "open(POUT, \"@cmd '$remcmd' |\")\n" };
    open(POUT, "@cmd '$remcmd' |");
    if ($timingsfile ne '') {
        open(TIMINGS, ">> $timingsfile")
          or warn "Couldn't open $timingsfile for writing\n";
    }
    my ($line,$timings,$result);
    while (defined($line=<POUT>)) {
        if ($line =~ /^#TIMING\s+(.*)/) {
            print "<$line>\n" if ($debug);
            print TIMINGS "$1\n";
            next;
        }
	print $line;
	$result .= $line;
    }
    if ($timingsfile ne '') {
        close TIMINGS;
    }
    close(POUT);

    # Put tag on files if auto-test breaks
    tag_breakage_on_error($result,$host) if ($tag_broken);
    tag_stable_on_success($result,$host) if ($tag_stable);

    # Send emails if necessary
    notify_on_error($result,$shost);

   $first = 0;
}
# ---------------------------------------------------------------------- #
sub build_remote_cmd {
# Construct the command to send to the remote host

    my $remcmd = "cd $pencil_home";
    if ($update)            { $remcmd .= "; svn -q update" };
    if ($UPDATE)            { $remcmd .=
                                "; svn -q update samples bin"
                            };
    $remcmd .= "; env PENCIL_HOME=$pencil_home ./bin/auto-test";
    $remcmd .= " --time";
    if ($with_xml)          { $remcmd .= " --xml" };
    if ($clean)             { $remcmd .= " --clean" };
    if ($reload)            { $remcmd .= " --reload" };
    if ($short)             { $remcmd .= " --short" };
    if ($nice)              { $remcmd .= " --nice=$nice" };
    if ($infofile ne '')    { $remcmd .= " --infofile=$infofile" };
    if ($postproc)          { $remcmd .= " --postproc=\"$postproc\"" };
    if ($timingsfile ne '') { $remcmd .= " --summarize-times" };

    return $remcmd;
}
# ---------------------------------------------------------------------- #
sub print_header {

    my $date = scalar localtime();
    my $xml = "";

    if ($with_xml) {
        $xml=<<"END_XMLHEAD";
<?xml version="1.0" encoding="utf-8"?>
<pc_penciltest version="0.1" xmlns:media="http://www.nordita.dk/software/pencil-code/penciltest">
<timestamp type="start">$date</timestamp>
END_XMLHEAD
    }
    if ($html) {
        print <<"END_HEAD";
<html>
<head></head>
<body>

$date
<p>
END_HEAD
    } else {
        print "$date\n\n";
    }
}
# ---------------------------------------------------------------------- #
sub print_footer {

    my $date = scalar localtime();
    if ($html) {
        print <<"END_FOOT";
<p>
$date
</pre>
</body>
</html>
END_FOOT
    }
    if ($with_xml) {
        $xml.=<<"END_XMLFOOT";
<timestamp type="end">$date</timestamp>
</pc_penciltest>
END_XMLFOOT
    }
}
# ---------------------------------------------------------------------- #
sub usage {
# Extract description and usage information from this file's header.
    my $thisfile = __FILE__;
    local $/ = '';              # Read paragraphs
    open(FILE, "<$thisfile") or die "Cannot open $thisfile\n";
    while (<FILE>) {
        next unless /^\s*#\s*Usage:/m; # Paragraph _must_ contain `Usage:'
        # Drop `Author:', etc:
        s/.*?\n(\s*\#\s*(Description|Usage):\s*\n.*)/$1/s;
        # Don't print comment sign:
        s/^\s*\# ?//mg;
        last;
    }
    $_;
}
# ---------------------------------------------------------------------- #
sub tag_stable_on_success{
## Put tag on files of auto-test succeeds
## [Most likely broken for SVN]
    my $result = (shift || '');
    my $host   = (shift || '');
    my $svncmd;

    return if ($result =~ /^Failed ([0-9]+) test/m);

    $svncmd=        "ssh -x -n $host 'cd \$PENCIL_HOME;";
    $svncmd=$svncmd."svn -q tag -d ".$tag_broken." src bin > /dev/null;" if ($tag_broken);
    $svncmd=$svncmd."svn -q tag -F ".$tag_stable." src bin > /dev/null";
    $svncmd=$svncmd."'";
    system($svncmd);
}
# ---------------------------------------------------------------------- #
sub tag_breakage_on_error{
## Put tag on files if auto-test breaks (only first break)
## [Most likely broken for SVN]
    my $result = (shift || '');
    my $host   = (shift || '');
    my $svncmd;
    if ($result =~ /^Failed ([0-9]+) test/m) {
# We only want to mark the first breakage... So check it isn't already tagged.
      my $hastag="ssh -x -n $host 'cd \$PENCIL_HOME; svn log -h Makefile.src'";
      return if ($hastag =~ /$tag_broken/);
# If we haven't already tagged it... Do so now.
      $svncmd=        "ssh -x -n $host 'cd \$PENCIL_HOME;";
      $svncmd=$svncmd."svn -q tag -F ".$tag_broken." src bin > /dev/null;";
      $svncmd=$svncmd."'";
      system($svncmd);
    }
}
# ---------------------------------------------------------------------- #
sub notify_on_error {
## Check for errors and send emails
    my $result = (shift || '');
    my $host   = (shift || '');

    my $failed_marker = '### auto-test failed ###'; # only in version of
                                                    # auto-test later than
                                                    # 27-Feb-2006

    return SUCCESS unless ($emails);  # nobody to report to

    my $failed = ($result =~ /^### auto-test failed ###$/m);
    print STDERR "\$failed (1) = <$failed>\n" if ($debug);
    my $nerrors = 0;
    if ($result =~ /^Failed ([0-9]+) test/m) { # get number of failed tests
        $failed = 1;
        $nerrors = $1;
    }
    if ($debug) {
        print STDERR "\$failed (2) = <$failed>\n";
        print STDERR "\$nerrors    = <$nerrors>\n";
        print STDERR "\$result     = <$result>\n";
    }

    return SUCCESS unless ($failed); # nothing to report

    # Analyze
    parse_emails($emails);      # ..so we can filter out individual tests
    my ($main,$summary)
      = split(/^----*\s*\n(?:$failed_marker\s*\n)?(?=Failed)/m,$result);
    if (defined($summary)) {
        # Extract list of failed directories
        my @failures = split(/\n/,$summary);
        ($nerrors) = ($failures[0] =~ /Failed ([0-9]+) test/);
        @failures = grep /^\s*\S+\s\(.*\)\s*$/, @failures;
        @failures = map { $_ =~ s/^\s*(\S*).*/$1/; $_ } @failures;
        foreach my $address (keys %emails) {
            foreach my $fail (@failures) {
                my $def_matches = ! any_match($fail,$neg{''});
                my $pos_matches = any_match($fail,$pos{$address});
                my $neg_matches = any_match($fail,$neg{$address});
                if (($def_matches || $pos_matches) && ! $neg_matches) {
                    if ($debug) {
                        print STDERR "...", substr($fail,-15,15),
                          ": \$sendmailto{$address}++\n";
                    }
                    $sendmailto{$address}++;
                }
            }
        }
    } else {
        warn "[No individual failing tests to report]\n";
        $summary = '';
        $nerrors = '';
        %sendmailto = %emails;  # Report this (probably another auto-test
                                # running) to everybody
    }

    # Send mail
    foreach my $address (keys %sendmailto) {
        send_mail($address,$mailer,$host,$nerrors,$blurb,$summary,$main);
    }
}
# ---------------------------------------------------------------------- #
sub write_timings {
## Append timing results to file
    my ($timings, $file) = @_;

    if (defined $timings) {
        print TIMINGS $timings;
        close(TIMINGS);
    }
}

# ---------------------------------------------------------------------- #
sub parse_emails {
# Parse the email list into hashes
    my $emaillist = shift;

    my ($entry,$address,$spec);
    print STDERR "Checking who to alert by email\n" if ($debug);
    while ($emaillist) {
	$emaillist =~ /^([^\}\{,]*(?:\{[^\}]*\})?),?(.*)/
	  or warn "Cannot parse email list <$emaillist>\n";
	($entry,$emaillist) = ($1,$2);
	($address,$spec) = ($entry =~ /([^\}\{]*)\{?([^\}]*)\}?/);
	$emails{$address}++ if ($address =~ /\S/);
	foreach my $sp (split(/,/,$spec)) {
	    if ($sp =~ /^\-:(.*)/) {
		push @{$neg{$address}}, $1
#		push @{$neg{$1}}, $address;
	    } elsif ($sp =~ /^\+:(.*)/) {
		push @{$pos{$address}}, $1
#		push @{$pos{$1}}, $address;
	    } else {
		warn "Strange specification: <$spec>\n";
	    }
	}
    }
}
# ---------------------------------------------------------------------- #
sub any_match {
# Match a string against a list of patterns
    my $string = shift;
    my $pattern_pointer = shift;
    my @patterns = ();

    if (ref($pattern_pointer) eq 'ARRAY') {
	@patterns = @{$pattern_pointer}
    };

    foreach my $patt (@patterns) {
        if ($string =~ /$patt$/) { return 1; }
    }
    return 0;
}
# ---------------------------------------------------------------------- #
sub send_mail {
# Send an email to the given address
    my $address = shift;
    my $mailer  = shift;
    my $host    = shift;
    my $nerrors = shift;
    my @text    = grep /./, @_;

    if (!$mailer) {
      if (in_PATH("mailx")) {
      $mailer = "mailx";
      } else {
      $mailer = "mail";
      }
    }

    my $errmsg;
    if ($nerrors =~ /[0-9]+/) { # number of failing individual tests
        my $plurals = ($nerrors<=1 ? '' : 's');
        $errmsg = "$nerrors error$plurals";
    } else {                    # most likely: lockfile exists
        $errmsg = "There are errors";
    }
    my @cmdline = ($mailer);
    push @cmdline, '-s', "$errmsg from pencil-code autotest on $host";

    my $mail = my $email = $ENV{EMAIL};
    if (defined($email)) {
        if ($email =~ /<([^>]*)>/) {
            $mail = $1;
        } else {
            $mail = $email;
        }
        if ($mail =~ /[-.a-zA-Z_0-9]+@[-.a-zA-Z_0-9]+/) {
            push @cmdline, '-a', "Reply-To: $email";
        }
    }

    push @cmdline, "$address";

    if ($debug) { print STDERR "\@cmdline = @cmdline\n" };
    my $sep = "\n" . "-" x 70 . "\n\n";
    open (MAIL, '|-', @cmdline);
    print MAIL join($sep, @text);
    print MAIL "\n";
    close MAIL;
}
# --------------------------------------------------------------------- #
sub in_PATH {
# Check whether an executable is available in the execution PATH
    my $file = shift;
    my $path;
    foreach $path (split(/:/,$ENV{PATH})) {
        if (-x "$path/$file") { return 1; }
    }
    return 0;
}
# ---------------------------------------------------------------------- #

# End of file pencil-test
