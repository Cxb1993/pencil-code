#!/usr/bin/perl -w

# Usage:
#   pc_script_test [dir1 [dir2 [...]]]
#
# Description:
#   Run tests in tests/ directories. These are normally tests of
#   Python or IDL scripts, or similar.
#   For each directory given, we recursively scan for subdirectories
#   named 'tests'. If no directories are given, the directories
#   tests/, samples/, runs/ of ${PENCIL_HOME} are used as starting
#   points.
#
#   Under each tests/ directory, we look for test files (which may be
#   located deeper in subdirectories).
#   The contract for a test file:
#   - It is named <test_name>.<suff>, where <suff> is a known suffix
#   - <suff> (currently supported: py, pro).
#   - The file is executable and can be run from the tests directory
#     (thus, many of the test scripts read data from '../data/').
#   - When run, the script writes a file <test_name>.out in the same
#     directory.
#   - There exist a file <test_name>.ref in the same directory that defines
#     the reference data and possibly accuracy.
#
#   Each test script is run (if we find an appropriate interpreter)
#   and the <test_name>.out file is compared to the reference data
#   <test_name>.ref .
#
# Examples:
#   pc_script_test       # Run all tests under $PENCIL_HOME/{tests,samples,runs}/
#   pc_script_test <dir> # Run all tests under the given directory

# # TODO:
# - scan directories for 'test'
# - find test files
# - for each test file:
# -   cd to its directory
# -   run it
# -   compare .ref and .out files
# -   [should we allow the case where no .ref exists and no .out is written?]
# -   Give some output [spinner or '.', or ...]
# - summarize results

use strict;


BEGIN {
    # Make sure ${PENCIL_HOME}/lib/perl is in the Perl path
    if (-d "$ENV{PENCIL_HOME}/lib/perl") {
        unshift @INC, "$ENV{PENCIL_HOME}/lib/perl";
    } else {
        if ($0 =~ m!(.*[/\\])!) { unshift @INC, "$1../lib/perl"; }
    }
}

use Pencil::Util;
Pencil::Util::use_pencil_perl_module('Test::NumericFileComparator')
  or die;

use Cwd qw/getcwd abs_path/;
use File::Basename;
use File::Find;
use File::Copy 'move';
use Test::NumericFileComparator;
use Getopt::Long;
# Allow for `-Plp' as equivalent to `-P lp' etc:
Getopt::Long::config("bundling");

my %opts;                     # Options hash for GetOptions

## Process command line
GetOptions(\%opts,
           qw( -h   --help
               -t=s --type=s
                    --debug
               -q   --quiet
               -v   --version
            )
          ) or die "Aborting.\n";

my $debug = ($opts{'debug'} ? 1 : 0 ); # undocumented debug option
if ($debug) {
    printopts(\%opts);
    print "\@ARGV = `@ARGV'\n";
}

my $cmdname = (split('/', $0))[-1];


if ($opts{'h'} || $opts{'help'})    { die usage();   }
if ($opts{'v'} || $opts{'version'}) { die version(); }

my $default_types = "python:idl";
my @types = split(/:/, $opts{'t'} || $opts{'type'}  || $default_types);
my $quiet = $opts{'q'} || $opts{'quiet'} || '';

my %type_map = (
    'python'  => '.py',
    'gdl'     => '.pro',
    'idl'     => '.pro',
);

my %run_dispatch_table = (
    python => \&run_python_script,
    idl    => \&run_idl_script,
);

my @default_dirs = (
    "$ENV{PENCIL_HOME}/tests",
    "$ENV{PENCIL_HOME}/samples",
    "$ENV{PENCIL_HOME}/runs",
    );
my @top_dirs = @ARGV
  ? @ARGV
  : @default_dirs;

my $idl_interpreter;
if (in_PATH('idl')) {
    $idl_interpreter = 'idl';
} elsif (in_PATH('gdl')) {
    $idl_interpreter = 'gdl';
} else {
    $idl_interpreter = '';
    @types = grep(!/^idl$/, @types); # remove 'idl' fromt test types
}

my @suffixes = get_suffixes(@types);

my $status = 0;
for my $test_dir (find_test_dirs(@top_dirs)) {
    for my $test_script (find_test_scripts($test_dir)) {
        my $status |= run_test($test_script);
    }
}

exit $status;


# ----------------------------------------------------------------------

sub run_test {
# Run test for one script
    my ($test_script) = @_;

    my ($file, $type) = @$test_script;
    my ($base, $dir, $suffix) = fileparse($file, @suffixes);
    die "Unexpected script file <$file>" unless $suffix;
    my $script = $base . $suffix;
    my $outfile = "${base}.out";
    my $reffile = "${base}.ref";

    my $action = $run_dispatch_table{$type};
    my $workdir = getcwd();
    chdir $dir;
    backup($outfile);

    my $ok = 1;
    $ok &= &$action($script);
    $ok &= compare_files($reffile, $outfile);

    chdir $workdir;
}


sub run_python_script {
    my ($file) = @_;

    my $ok;
    debug("Running Python script $file from ", getcwd());
    my $status = system('python', $file);
    debug("  -> status: ", $status + 0, "\n");
    return $status == 0;
}


sub run_idl_script {
    my ($file) = @_;

    my $ok;
    debug("Running IDL script $file using $idl_interpreter");
    my $status = system($idl_interpreter, $file);
    debug("  -> status: ", $status + 0, "\n");
    return $status == 0;
}


sub compare_files {
    my ($reference, $actual) = @_;

    my $comparator = Test::NumericFileComparator->new($reference);

    # Compare file to reference data
    my @message = $comparator->compare($actual);
    if (@message) {
        print "File $actual differs: @message\n";
        return 0;
    } else {
        return 1;
    }
}

sub in_PATH {
# Check whether an executable is available in the execution PATH
    my ($file) = @_;

    foreach my $path (split(/:/,$ENV{PATH})) {
        if (-x "$path/$file") { return 1; }
    }
    return 0;
}


sub backup {
# Move $file to $file.old if applicable
# An existing backup file will be overwritten without further ado.
    my ($file) = @_;

    if (-e $file) {
        move $file, "${file}.old";
    }
}


sub get_suffixes {
# Map a list of file types to a list of supported suffices.
    my @types = @_;

    my @suffixes;
    for my $type (@types) {
        push @suffixes, type_to_suffix($type);
    }
    return @suffixes;
}


sub type_to_suffix {
# Map test type (e.g. 'idl') to suffix of executable files ('pro' in the
# example)
    my ($type) = @_;

    my $suffix = $type_map{$type};
    if (defined $suffix) {
        return $suffix;
    } else {
        die "Unknown test type <$type>\n";
    }
}


sub suffix_to_type {
# Map suffix (e.g. '.pro') to enabled test type (e.g. 'idl')
    my ($suffix) = @_;

    for my $type (@types) {
        if ($type_map{$type} eq $suffix) {
            return $type;
        }
    }
    die "Unknown test file suffix <$suffix>\n";
}


sub find_test_dirs {
# Find all test directories at or below the given @top_dirs.
# We do not recurse further into identified test directories.
    my @top_dirs = @_;

    my @dirs;
    for my $dir (@top_dirs) {
        $dir = abs_path($dir);
        if (is_test_dir($dir)) {
            push @dirs, $dir;
        } else {
            File::Find::find({
                    wanted => sub {
                        my $name = $File::Find::name;
                        if (is_test_dir($name)) {
                            push @dirs, $name;
                            $File::Find::prune = 1;
                        }
                    },
                    follow => 1,       # follow symlinks
                    follow_skip => 2,  # ignore duplicates
                },
                $dir
            );
        }
    }

    return @dirs;
}


sub find_test_scripts {
# Find all test scripts below any of @dir.
# A test script has a known suffix and is executable.
# Return an array ref [$filename, $type]
    my @dirs = @_;

    my @scripts;
    for my $dir (@dirs) {
        File::Find::find({
                wanted => sub {
                    my $name = $File::Find::name;
                    my $type = is_test_script($name);
                    if ($type) {
                        push @scripts, [$name, $type];
                    }
                },
                follow => 1,       # follow symlinks
                follow_skip => 2,  # ignore duplicates
            },
            $dir
        );
    }

    return @scripts;
}


sub is_test_dir {
# Does the given $path represent a test directory?
    my ($path) = @_;

    my ($name, undef, undef) = fileparse($path);
    return (-d $path) && ($name =~ '^tests$');
}


sub is_test_script {
# Does the given $path represent a test script?
# Return the test type if it does, '' otherwise
    my ($path) = @_;

    my ($name, $dir, $suffix) = fileparse($path, @suffixes);
    if ((-x $path) && $suffix) {
        return suffix_to_type($suffix);
    } else {
        return '';
    }
}


sub debug {
    my @args = @_;

    if ($debug) {
        my $string = join(' ', @args);
        chomp($string);
        print "$string\n";
    }
}


sub printopts {
# Print command line options
    my ($optsref) = @_;
    my %opts = %$optsref;
    foreach my $opt (keys(%opts)) {
        print STDERR "\$opts{$opt} = '$opts{$opt}'\n";
    }
}


sub usage {
# Extract description and usage information from this file's header.
    my $thisfile = __FILE__;
    local $/ = '';              # Read paragraphs
    open my $fh, '<', $thisfile or die "Cannot open $thisfile\n";
    while (<$fh>) {
        # Paragraph _must_ contain `Description:' or `Usage:'
        next unless /^
                     \s* \# \s*
                     ( Description | Usage )
                     :
                    /mx;
        # Drop `Author:', etc. (anything before `Description:' or `Usage:')
        s/^
          (?: .*? \n) ??
          (
              \s* \# \s*
              (?: Description | Usage )
              :
              \s*
              \n
              .*
          )
         / $1
         /sx;
        # Don't print comment sign:
        s/^\s*# ?//mg;
        last;                        # ignore body
    }
    close $fh;
    return $_ or "<No usage information found>\n";
}


sub version {
# Return SVN/CVS data and version info.
    my $doll='\$';              # Need this to trick SVN/CVS
    my $rev = '$Revision: 1.12 $';
    my $date = '$Date: 2008/07/07 21:37:16 $';
    $rev =~ s/${doll}Revision:\s*(\S+).*/$1/;
    $date =~ s/${doll}Date:\s*(\S+).*/$1/;

    return "$cmdname version $rev ($date)\n";
}
