#!/bin/sh
#  -*-Perl-*-
#======================================================================#
# Run the right perl version:
if [ -x /usr/local/bin/perl ]; then
  perl=/usr/local/bin/perl
elif [ -x /usr/bin/perl ]; then
  perl=/usr/bin/perl
else
  perl=`which perl| sed 's/.*aliased to *//'`
fi

exec $perl -x -S $0 "$@";     # -x: start from the following line
#======================================================================#
#! /Good_Path/perl -w 
# line 17

# Name:   mkcparam
# Author: wd (Wolfgang.Dobler@kis.uni-freiburg.de)
# Started:   06-Jul-2002
# CVS: $Id: mkcparam,v 1.29 2004-04-06 11:53:32 ajohan Exp $
# Usage:
#   mkcparam <file1> [<file2> [..]] [-o outfile]\n
# Description:
#   Check the headers (everything before the first non-comment non-empty
#   line) of input files for lines of the sort
#     ! MVAR CONTRIBUTION 3
#     ! MAUX CONTRIBUTION 1
#     ! NDUSTSPEC CONTRIBUTION 17
#   and accumulate the numbers mvar, maux, ndustspecs, etc from these.
#
#   Output is written as a Fortran program and supposed to end up in the
#   local file src/cparam.inc .
# Example:
#     mkcparam entropy.f90 nomagnetic.f90 hydro.f90 > src/cparam.inc

# History:
#   30-nov-02/tony: Modified to use makefile lines where the Make variable
#                   and module name differ by more than just case
#                     e.g.   VISCOSITY=visc_shock
#                   Also count maux variables too.
#
#   12-oct-03/tony: Modified to use in-code declarations of f-array
#                   contributuions. 
#                   Fortran files should contain a block like the
#                   following at the top to declare any contribution
#                   they make to the f-array.
#

# ---------------------------------------------------------------------- #
my $mvar_decl = '^\s*!\s*MVAR\s*CONTRIBUTION\s*([0-9]+)\s*$';
my $maux_decl = '^\s*!\s*MAUX\s*CONTRIBUTION\s*([0-9]+)\s*$';
my $dust_decl = '^\s*!\s*NDUSTSPEC\s*CONTRIBUTION\s*([0-9]+\*[0-9])\s*$';
# ---------------------------------------------------------------------- #

use strict;
use Getopt::Long;

my $line;
my $dust_string='1*4';
my $lmdvar='.false.';
my $lrhoice='.false.';
my ($maux,$mvar,$ndustspec,$mvar_per_dust) = (0) x 4;

(my $cmdname = $0) =~ s{.*/}{};

## Process command line
my (%opts);	# Variables written by GetOptions
GetOptions(\%opts,
	   qw( -h   --help
	       -o=s --output=s
                               ));

die usage() if ((@ARGV == 0) || $opts{h} || $opts{help});

my $outfile = ($opts{o} || $opts{output} || "-");
open(OUT, "> $outfile") or die "Can't open $outfile for writing";

# Cycle through files (later files will overwrite effect of earlier files)
file: foreach my $infile (@ARGV) {
# Now extract `?VAR CONTRIBUTION' info from each file
    unless (open(INPUT,"< $infile")) {
	warn "Can't open $infile for reading";
	next file;
    }
# Cycle through all lines up to first non-empty non-comment line in file
    line: while (defined($line=<INPUT>)) {
	next line if ($line =~ /^\s*$/); # ignore empty lines
	last line if ($line !~ /^\s*!/); # done if non-comment line
	extract_decl($line,$mvar_decl,\$mvar       );
	extract_decl($line,$maux_decl,\$maux       );
# Check for information about number of dust species and discretization type   
	if ($line=~ /$dust_decl/) {$dust_string=$1;}
    }
}
# More processing of dust information
($ndustspec,$mvar_per_dust) = split /\*/, $dust_string;
if ($ndustspec >= 1) {
  $mvar = $mvar - 4;
  $mvar = $mvar + $ndustspec*$mvar_per_dust;
  }
if ($mvar_per_dust >= 5) {$lmdvar = '.true.';}
if ($mvar_per_dust == 6) {$lrhoice = '.true.';}


## Write output
print OUT <<"EOF";
!                       -*-f90-*- (for Emacs)
!  cparam.inc
!
! This file was automatically generated by $cmdname, so think twice before
! you modify it. It is included by cparam.f90 .
!

integer, parameter :: mvar=$mvar, maux=$maux
integer, parameter :: ndustspec=$ndustspec
logical, parameter :: lmdvar=$lmdvar, lrhoice=$lrhoice

EOF

# ---------------------------------------------------------------------- #
sub extract_decl{
## Extract declaration of contribution to mvar and similar
    my $line = shift;
    my $regexp = shift;
    my $counter_ref = shift;

    if ($line =~ /$regexp/) {
	  $$counter_ref += $1;
      }
}

# ---------------------------------------------------------------------- #
sub usage {
# Extract description and usage information from this file's header.
    my $thisfile = __FILE__;
    local $/ = '';              # Read paragraphs
    open(FILE, "<$thisfile") or die "Cannot open $thisfile\n";
    while (<FILE>) {
	# Paragraph _must_ contain `Description:' or `Usage:'
        next unless /^\s*\#\s*(Description|Usage):/m;
        # Drop `Author:', etc. (anything before `Description:' or `Usage:')
        s/.*?\n(\s*\#\s*(Description|Usage):\s*\n.*)/$1/s;
        # Don't print comment sign:
        s/^\s*# ?//mg;
        last;                        # ignore body
    }
    $_ or "<No usage information found>\n";
}
# ---------------------------------------------------------------------- #

# End of file mkcparam
