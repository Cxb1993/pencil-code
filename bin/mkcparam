#!/bin/sh
#  -*-Perl-*-
#======================================================================#
# Run the right perl version:
if [ -x /usr/local/bin/perl ]; then
  perl=/usr/local/bin/perl
elif [ -x /usr/bin/perl ]; then
  perl=/usr/bin/perl
else
  perl=`which perl| sed 's/.*aliased to *//'`
fi

exec $perl -x -S $0 "$@";     # -x: start from the following line
#======================================================================#
#! /Good_Path/perl -w 
# line 17

# Name:   mkcparam
# Author: wd (Wolfgang.Dobler@kis.uni-freiburg.de)
# Date:   06-Jul-2002
# CVS: $Id: mkcparam,v 1.9 2002-12-13 18:42:38 brandenb Exp $
# Description:
#   Going through the input files, check for lines of the sort
#     MAGNETIC=magnetic
#   and calculate the number mvar of variables and maux of variables 
#   accordingly.
#
#   Output is written as a Fortran program and supposed to end up in the
#   local file src/cparam.inc .
#
#   30-nov-02/tony: Modified to use makefile lines where the Make variable
#                   and module name differ by more than just case
#                     e.g.   VISCOSITY=visc_shock
#                   Also count maux variables too.
#
# ---------------------------------------------------------------------- #
my %modules = ( # module_name { option => contribution to mvar, ...}, ...
	        HYDRO     => { hydro     => 3, nohydro     => 0 },
	        DENSITY   => { density   => 1, nodensity   => 0 },
	        ENTROPY   => { entropy   => 1, noentropy   => 0 ,
                                               temperature => 1 },
	        MAGNETIC  => { magnetic  => 3, nomagnetic  => 0 },
		RADIATION => { radiation => 5, noradiation => 0 },
		PSCALAR   => { pscalar   => 1, nopscalar   => 0 },
	      );
my %auxmodules=(# module_name { option => contribution to mvar, ...}, ...
		   VISCOSITY => { visc_shock => 1, visc_const => 0 }
	      );
my $identifier = "[a-zA-Z0-9_]"; # module names must consist of these
# ---------------------------------------------------------------------- #

use strict;
use Getopt::Long;

my $line;
my %modcounts;
my %auxmodcounts;

(my $cmdname = $0) =~ s{.*/}{};
my $usage =
"Usage:  $cmdname <file1> [<file2> [..]] [-o outfile]\n
Going through the input files, check for lines of the sort
  MAGNETIC=magnetic
and calculate the number mvar of variables accordingly. Output is written
as a Fortran program that can be included by cparam.f90.
E.g.
  $cmdname src/Makefile src/Makefile.local > src/cparam.inc
will generate a file that takes into account that Makefile.local overwrites
settings from Makefile.";


## Process command line
my (%opts);	# Variables written by GetOptions
GetOptions(\%opts,
	   qw( -h   --help
	       -o=s --output=s
                               ));

die "$usage\n" if ((@ARGV == 0) || $opts{h} || $opts{help});

my $outfile = ($opts{o} || $opts{output} || "-");

open(OUT, "> $outfile") or die "Can't open $outfile for writing";

# Cycle through files (later files will overwrite effect of earlier files)
foreach my $infile (@ARGV) {
    open(INPUT,"< $infile") || die "Can't open $infile for reading";
    # Cycle through lines in file
  file: while (defined($line=<INPUT>)) {
      # Only definitions of Make variables are interesting:
      next unless ($line =~ /^\s*$identifier+\s*=\s*$identifier+/);
      # cycle through module list and check
    key: while (my ($MOD) = each %modules) {
	if ($line =~ /^\s*$MOD\s*=\s*($identifier*)($|\s)/) {
	  key2: while (my ($opt, $count) = each %{$modules{$MOD}}) {
	      if ($1 eq $opt) { # `mod' is used
		  $modcounts{$MOD}{$opt} = $count; 
		  # overwrite
		  # existing value
	      } else {	# `nomod' is used (or not `mod' in any case)
		  $modcounts{$MOD}{$opt} = 0;
	      }
	  }
	}
    }
      
      # cycle through auxilliary module list and check
    key3: while (my ($MOD) = each %auxmodules) {
	if ($line =~ /^\s*$MOD\s*=\s*($identifier*)($|\s)/) {
	  key4: while (my ($opt, $count) = each %{$auxmodules{$MOD}}) {
	      if ($1 eq $opt) { # `mod' is used
		  $auxmodcounts{$MOD}{$opt} = $count; 
		  # overwrite
		  # existing value
	      } else {	# `nomod' is used (or not `mod' in any case)
		  $auxmodcounts{$MOD}{$opt} = 0;
	      }
	  }
	}
    }
  }
}


# use Data::Dumper;
#print Dumper(\%modules,\%modcounts);
#print Dumper(\%auxmodules,\%auxmodcounts);
#while (my ($MOD) = each %modules) {
#		  print $MOD,  "\n"; #, $modules{$MOD}{$opt};
#	      key2: while (my ($opt, $count) = each %{$modules{$MOD}} ) {
#  print $MOD, " - ", $opt, " = ", $count, "\n"; #, $modules{$MOD}{$opt};
#	      }
#}

## Extract maux..
my $maux=0;
while (my ($MOD) = each %auxmodcounts) {
    foreach( values(%{$auxmodcounts{$MOD}}) ) {
	$maux += $_;
    }
}

## Extract mvar..
my $mvar=0;
while (my ($MOD) = each %modcounts) {
    foreach( values(%{$modcounts{$MOD}}) ) {
	$mvar += $_;
    }
}



## ..and write output
print OUT <<"EOF";
!                    -*-f90-*-  (for Emacs)
!  cparam.inc
!
! This file was automatically generated by $cmdname, so think twice before
! you modify it. It is included by cparam.f90 .
!

integer, parameter :: mvar=$mvar, maux=$maux
EOF

# End of file mkcparam
