#!/usr/bin/perl
# Fortran95 coding style tester for the Pencil Code style.
# Currently, only basic checks are performed, e.g. indentation.
# Feel free to add more tests carefully.
#
# More general information about good Fortran95 coding style:
# https://code.google.com/p/pencil-code/wiki/CodingStyle
#
# Command-line arguments:
# -a: automatic correction, where possible
# -b: backups original, if changes are applied
# -q: quiet
# -l: loose checking
# -v: verbose ouput
# -d: debug ouput
#
# 17.11.2015, Bourdin.KIS: coded.
# $Id$

use strict;

# settings
my $indentation_str = "  ";
my $continuation_str = "    ";
my $tab_to_spaces_str = "        ";
my $max_line_length = 131;
my $preferred_line_length = 80;
my @trigger_indent = ("program", "module", "contains", "interface", "type", "subroutine", "function", "where", "do", "repeat", "if", "select");
my @trigger_unindent = ("program", "module", "interface", "type", "subroutine", "function", "where", "do", "if", "select");
my @data_types = ("integer", "real", "logical", "character", "double precision");
my @require_separator = (".and.", ".or.", ".not.", ".true.", ".false.", ".eqv.", ".neqv.");
my @require_spaces = ("=");
my %replace = (".gt." => " > ", ".lt." => " < ", ".ge." => " >= ", ".le." => " <= ", ".eq." => " == ", ".ne." => " /= ");

# command line arguments
my $picky = 1;
my $auto_correct = 0;
my $quiet = 0;
my $backup = 0;
my $verbose = 0;
while ($ARGV[0] =~ /^-/) {
	my $argument = shift ();
	if (lc ($argument) eq "-l") { $picky = 0; }
	elsif (lc ($argument) eq "-v") { if ($verbose < 1) { $verbose = 1; } }
	elsif (lc ($argument) eq "-d") { $verbose = 2; }
	elsif (lc ($argument) eq "-q") { $quiet = 1; }
	elsif (lc ($argument) eq "-a") { $auto_correct = 1; }
	elsif (lc ($argument) eq "-b") { $backup = 1; }
	else {
		usage ("Option \"".$argument."\" unkown ...");
	}
}
my $num_files = @ARGV;
if ($num_files == 0) { usage (""); }

# initialize globals and scan file
my %state = ();
my @lines = [""];
my @line_numbers = [0];
my $pos = 0;
my $num_warnings = 0;
my $num_fixed = 0;
my $num_fatals = 0;
my $indentation = length ($indentation_str);
my $num_trigger_indent = @trigger_indent;

# process filenames
my $num_file = 0;
my $exit_code = 0;
my $filename = "";
while ($filename = shift ()) {
	if ($num_file > 0) {
		print ("========================================================================\n");
	}
	$num_file++;
	if (!$quiet && ($num_files > 1)) {
		print ('File "'.$filename.'":'."\n");
	}
	if (!-e $filename) { die ('No such file or directory: "'.$filename.'"'."\n"); }
	if (!-f $filename) { die ('Not a file: "'.$filename.'"'."\n"); }
	scan_file ($filename);
	print STDERR ('File "'.$filename.'":'."\n");
	print STDERR ("=> ");
	if ($auto_correct && ($num_fatals == 0)) {
		write_file ($filename);
	}
	print_num_warnings ();
}
exit ($exit_code);


sub usage {
	my ($message) = @_;
	if ($message) { warn ($message."\n"); }
	warn ("Usage: ".$0." [-a] [-b] [-l] [-v] [-d] [-q] filename\n");
}

sub scan_file {
	# reset global state
	$state{'indent'} = 0;
	$state{'indent_str'} = "";
	$state{'nesting'} = "";
	$state{'last_nesting'} = "";
	$state{'continuation'} = 0;
	$state{'multiline_if'} = 0;
	$state{'multiline_where'} = 0;
	$state{'else_branch'} = "";
	$state{'eol_comment'} = 0;
	$state{'complete_line'} = "";

	# read file
	my $num_lines = 0;
	my $orig_line_number = 0;
	@lines = [""];
	open (FILE, "< ".$filename);
	while (defined (my $line = <FILE>)) {
		$num_lines++;
		$orig_line_number++;
		$line =~ s/\n$//s;
		# split multi-line commands
		my $clean_line = cut_comment ($line);
		while ($clean_line =~ s/^(.*?) *\; */<auto-indent>/s) {
			$line =~ s/^(.*?) *\; */<auto-indent>/s;
			$lines[$num_lines] = $1."<remove-MLC>";
			$line_numbers[$num_lines] = $orig_line_number;
			$num_lines++;
		}
		$lines[$num_lines] = $line;
		$line_numbers[$num_lines] = $orig_line_number;
	}
	close (FILE);

	# parse and check file
	for ($pos = 1; $pos <= $num_lines; $pos++) {
		$_ = $lines[$pos];

		# reset per-line state
		$state{'fixed_multiple_commands'} = 0;
		$state{'fixed_require_separator'} = 0;
		$state{'fixed_equals_require_space'} = 0;
		$state{'num_warnings'} = 0;
		$state{'num_fixed'} = 0;
		$state{'num_fatals'} = 0;

		# white-spaces
		if (/\r$/s) {
			warning ("convert to 'unix EOL'-format");
			s/\r$//s;
		}
		if (/\r/s) {
			warning ("unallowed 'carriage-return' character");
			s/\r//gs;
		}
		if (/\f/s) {
			warning ("unallowed 'form-feed' character");
			s/\f//gs;
		}
		if (/\t/s) {
			warning ("unallowed 'tabulator' character");
			s/\t/${tab_to_spaces_str}/gs;
		}
		if (/\s+$/s) {
			warning ("remove 'spaces' at end of line");
			s/\s*$//s;
		}
		if (/ +,/s) {
			warning ("remove 'spaces' before a comma");
			s/ +,/,/s;
		}

		# comments
		if (/^$/) {
			warning ("empty lines should have a '!' in front");
			$_ = "!";
		}
		my $no_strings = cut_strings ($_);
		if ($no_strings =~ /^( +)\!/s) {
			my $spaces = $1;
			my $num_spaces = length ($spaces);
			if ($num_spaces != $state{'indent'}) {
				if (($state{'eol_comment'} > 0) && ($num_spaces > $state{'indent'})) {
					# multi-line comment block with extra indentation
					fixme_warning ("no extra indentation for multi-line comment blocks");
				}
				else {
					warning ("comments start either at the beginning of a line or at the correct indentation level");
					if (($num_spaces > $state{'indent'}*4/3) && ($num_spaces >= 4)) {
						$spaces = $state{'indent_str'};
					}
					else {
						$spaces = "";
					}
					s/^ +\!/${spaces}\!/s;
				}
			}
		}
		if (/^ *\!\!+ */s) {
			# double commenting
			picky_warning ("comments start with only one exclamation mark");
			s/^( *\!)\!+ */${1} /s;
		}
		$lines[$pos] = $_;
		if (/^ *\!/s) {
			# this line contains only a comment
			next;
		}
		if ($no_strings =~ /\S *\!/s) {
			# comment at end of line
			picky_fixme_warning ("avoid end-of-line comments");
			$state{'eol_comment'} = 1;
		}
		else {
			$state{'eol_comment'} = 0;
		}

		# replace
		while (my ($search, $replace) = each (%replace)) {
			my $pattern = $search;
			$pattern =~ s/\./\\\./gs;
			if (/${pattern}/is) {
				warning ("replace '".$search."' by '".$replace."'");
				s/${pattern}/${replace}/gis;
				$lines[$pos] =~ s/${pattern}/${replace}/gis;
			}
		}

		# require spaces
		foreach my $item (@require_spaces) {
			my $clear_line = cut_brackets ($_);
			$clear_line =~ s/ *::.*$//s;
			my $exclude = "";
			if ($item eq "=") { $exclude = "<>\\/="; }
			while ($clear_line =~ s/^(.*?[^ ${exclude}])(${item})/${1} ${2}/is) {
				my $pre = length ($1);
				if ($state{'fixed_equals_require_space'} == 0) {
					picky_warning ("'".$item."' should be surrounded by spaces for readability");
				}
				s/^(.{${pre}})(${item})/${1} ${2}/is;
				$lines[$pos] =~ s/^(.{${pre}})(${item})/${1} ${2}/is;
				$state{'fixed_equals_require_space'}++;
			}
			while ($clear_line =~ s/^(.*?[^${exclude}]${item})([^ ${exclude}])/${1} ${2}/is) {
				my $pre = length ($1);
				if ($state{'fixed_equals_require_space'} == 0) {
					picky_warning ("'".$item."' should be surrounded by spaces for readability");
				}
				s/^(.{${pre}})([^ ${exclude}])/${1} ${2}/is;
				$lines[$pos] =~ s/^(.{${pre}})([^ ${exclude}])/${1} ${2}/is;
				$state{'fixed_equals_require_space'}++;
			}
		}

		# require separator
		foreach my $item (@require_separator) {
			my $pattern = $item;
			$pattern =~ s/\./\\\./gs;
			while (/[^ \(\)=,]${pattern}/is) {
				if ($state{'fixed_require_separator'} == 0) {
					warning ("separator is required before and after '".$item."'");
				}
				s/([^ \(\)=,])${pattern}/${1} ${item}/is;
				$lines[$pos] =~ s/([^ \(\)=,])${pattern}/${1} ${item}/is;
				$state{'fixed_require_separator'}++;
			}
			while (/${pattern}[^ \(\)=,]/is) {
				if ($state{'fixed_require_separator'} == 0) {
					warning ("separator is required before and after '".$item."'");
				}
				s/${pattern}([^ \(\)=,])/${item} ${1}/is;
				$lines[$pos] =~ s/${pattern}([^ \(\)=,])/${item} ${1}/is;
				$state{'fixed_require_separator'}++;
			}
		}

		# jumping around
		if (/, *end *=/is) {
			accumulative_fatal ("'end=' is forbidden => use 'iostat=' instead, a conditional 'exit' may help in loops");
		}
		if (/, *err *=/is) {
			accumulative_fatal ("'err=' is forbidden => use 'iostat=' instead, a conditional 'exit' may help in loops");
		}

		# format strings
		if (/, *fmt *= *(\d+)/is) {
			accumulative_fatal ("'fmt=".$1."' is forbidden => better move the format string directly there");
		}

		# absolutely forbidden
		if (/(?:^| )goto /is) {
			fatal ("'goto' is absolutely forbidden => use proper control structures, like 'if-else' or 'do-while-repeat'");
			return;
		}
		if (/(?:^| )entry /is) {
			fatal ("'entry' is absolutely forbidden => use 'interface' instead");
			return;
		}

		# indentation
		if (check_closed_nesting ($_)) { return; }
		if ($state{'indent'} < 0) {
			fatal ("surplus 'end' => indentation became negative");
			return;
		}
		my $start_spaces = $state{'indent_str'};
		if ($state{'continuation'} > 0) { $start_spaces .= $continuation_str; }
		if (!/^${start_spaces}\S/s) {
			if (($state{'continuation'} <= 1) || (($state{'continuation'} >= 2) && (!/^${start_spaces}${continuation_str}\S/s))) {
				if ($verbose) { print "NESTING:".$state{'nesting'}." INDENT:".$state{'indent'}."\n"; }
				if (!/^ *<auto-indent>/s) {
					warning ("wrong indentation level");
				}
				s/^ *(?:<auto-indent> *)?/${start_spaces}/s;
				$lines[$pos] =~ s/^ *(?:<auto-indent> *)?/${start_spaces}/s;
			}
		}
		if (check_new_nesting ($_)) { return; }

		# multiple commands per line
		if (/<remove-MCL>$/s && ($state{'fixed_multiple_commands'} <= 0)) {
			picky_warning ("possible multi-command line => better put one command per line");
			s/ *<remove-MCL>$//s;
			$lines[$pos] =~ s/ *<remove-MCL>$//s;
		}

		# construct complete line
		$state{'complete_line'} .= $lines[$pos];
		$state{'complete_line'} =~ s/ *\&$//s;
		$state{'complete_line'} =~ s/(\S) {2,}/${1} /gs;

		# continuation
		if (/\&$/s) {
			$state{'continuation'}++;
		}
		else {
			if ($state{'continuation'} > 0) {
				# end of continuation
				if (/[^&]$/s && (length ($state{'complete_line'}) <= $preferred_line_length)) {
					# unneeded breaking
					warning ("unneeded continuation-line break");
					for (my $remove = 1; $remove <= $state{'continuation'}; $remove++) {
						$lines[$pos-$remove] = "<remove-me>";
					}
					$lines[$pos] = $state{'complete_line'};
				}
			}
			$state{'continuation'} = 0;
			$state{'complete_line'} = "";
		}

		# line length
		if (length ($lines[$pos]) > $max_line_length) {
			accumulative_fatal ("line longer than ".$max_line_length." characters");
		}
	}

	# test for open indentation
	if ($state{'nesting'} ne "") {
		$pos = $num_lines;
		my $last_nesting = "";
		if ($state{'nesting'} =~ /([^\|]+)\|+$/s) { $last_nesting = $1; }
		accumulative_fatal ("indentation is still open at EOF => missing 'end".$last_nesting."'-statement");
	}

	# file-global checks
	$_ = join ("\n", @lines);
	s/(?:\n<remove-me>)+//gs;

	# empty else-blocks
	while (/(^.*?\n) *else(|where)(\n\![^\n]*)*\n *end *(|if|where)(?: |\n)/is) {
		my $pre = $1;
		my $type = $2;
		my $empty = $3;
		my $closing = $4;
		$pre =~ s/[^\n]+//gs;
		$pos = length ($pre);
		if ($type && (lc ($closing) ne lc ($type))) {
			$empty =~ s/[^\n]+//gs;
			$pos += length ($empty) + 1;
			fatal ("misplaced 'end".$closing."' after empty 'else".$type."'-block => better use the pure 'end'-statement");
			return;
		}
		warning ("remove empty 'else".$type."'-block");
		s/\n *else${type}(?:\n\![^\n]*)*(\n *end *${closing}(?: |\n))/${1}/is;
	}

	# split into lines again
	@lines = split (/\n/s, $_);
}

sub cut_brackets {
	my ($line) = cut_comment (@_);
	if ($line =~ /\(((?:[^_\(\)]|\(_*\))(?:[^\(\)]*(?:\(_*\)[^\(\)]*)*)*)\)/s) {
		my $content = $1;
		if ($content =~ /^_*$/s) { return ($line); }
		my $replace = '_' x length ($content);
		$line =~ s/\(((?:[^_\(\)]|\(_*\))(?:[^\(\)]*(?:\(_*\)[^\(\)]*)*)*)\)/\(${replace}\)/s;
		$line = cut_brackets ($line);
	}
	return ($line);
}

sub cut_comment {
	my ($line) = cut_strings (@_);
	$line =~ s/ *\!.*$//s;
	return ($line);
}

sub cut_strings {
	my ($line) = @_;
	my $old_line = "";
	while ($line =~ /^(.*?)(['"])(.*)$/s) {
		my $pre = $1;
		my $type = $2;
		my $post = $3;
		if ($pre =~ /\!/s) { return ($line); }
		my $fill = "";
		while ($post =~ /^(.*?)${type}(.*)$/s) {
			my $string = $1;
			my $rest = $2;
			if (!$fill) { $fill = '_' x length ($string); }
			$string =~ s/\\\\//gs;
			if ($string !~ s/\\$//s) {
				my $type_str = "";
				if ($type eq '\'') { $type_str = "apostroph"; }
				if ($type eq '"') { $type_str = "quote"; }
				$line = $pre."<type-".$type_str.">".$fill."<type-".$type_str.">".$rest;
				last;
			}
			$post = $string.$rest;
		}
		if ($old_line eq $line) { last; }
		$old_line = $line;
	}
	$line =~ s/<type-quote>/"/gis;
	$line =~ s/<type-apostroph>/'/gis;
	return ($line);
}

sub picky_fixme_warning {
	my ($message) = @_;
	if (!$picky) { return; }
	fixme_warning ("picky: ".$message);
}

sub picky_warning {
	my ($message) = @_;
	if (!$picky) { return; }
	warning ("picky: ".$message);
}

sub fixme_warning {
	my ($message) = @_;
	print_warning ($message);
	if ($num_fatals > 0) { perish (); }
}

sub warning {
	my ($message) = @_;
	if ($auto_correct) {
		$message = "fixed: ".$message;
	}
	$num_fixed++;
	$state{'num_fixed'}++;
	print_warning ($message);
	if ($num_fatals > 0) { perish (); }
}

sub print_warning {
	my ($message) = @_;
	$num_warnings++;
	$state{'num_warnings'}++;
	if (!$quiet) { warn ("[".$line_numbers[$pos]."] ".$message."\n"); }
}

sub write_file {
	my ($filename) = @_;
	if ($num_fixed == 0) {
		# no automatic changes applied
		warn ("NO automatic changes applied.\n");
		return;
	}
	if ($backup) {
		# create backup of unchanged file
		my $suffix = ".bak";
		my $backup_file = $filename.$suffix;
		my $counter = 0;
		while (-e $backup_file) {
			$counter++;
			$backup_file = $filename.$suffix.".".$counter
		}
		system ('mv "'.$filename.'" "'.$backup_file.'"');
	}
	# write auto-corrected file
	shift (@lines);
	$_ = join ("\n", @lines)."\n";
	open (FILE, "> ".$filename);
	print FILE $_;
	close (FILE);
}

sub print_num_warnings {
	if ($auto_correct) {
		my $num_unfixed = ($num_warnings - $num_fixed);
		if ($num_fixed > 0) {
			if ($num_fatals > 0) {
				warn ($num_fixed." STYLE BREAKS can be fixed automatically, once all FATAL ERRORS are solved.\n");
			}
			else {
				warn ($num_fixed." STYLE BREAKS were fixed.\n");
			}
		}
		if ($num_unfixed > 0) {
			warn ($num_unfixed." STYLE BREAKS need to be fixed manually.\n");
		}
		if ($num_fatals > 0) {
			warn ($num_fatals." FATAL ERRORS still remain!\n");
		}
	}
	else {
		if ($num_warnings > 0) {
			warn ($num_warnings." STYLE BREAKS should be fixed.\n");
		}
		if ($num_fixed > 0) {
			warn ($num_fixed." of them can be fixed automatically!\n");
		}
		if ($num_fatals > 0) {
			warn ($num_fatals." FATAL ERRORS still remain!\n");
		}
	}
	if (($num_warnings == 0) && ($num_fixed == 0) && ($num_fatals == 0)) { warn ("everything OK, congratulations!\n"); }
	$num_warnings = 0;
	$num_fixed = 0;
	$num_fatals = 0;
}

sub accumulative_fatal {
	my ($message) = @_;
	$num_fatals++;
	$state{'num_fatals'}++;
	print_warning ("FATAL: ".$message);
}

sub fatal {
	my ($message) = @_;
	$num_fatals++;
	$state{'num_fatals'}++;
	fixme_warning ("FATAL: ".$message);
	perish ();
}

sub perish {
	$exit_code = 1;
}

sub add_nesting {
	my ($nesting) = @_;
	if ($verbose >= 2) { warn ("[".$line_numbers[$pos]."] ADD: ".$nesting."\n"); }
	$state{'nesting'} .= $nesting.'|';
	$state{'last_nesting'} = $nesting;
	$state{'indent'} += $indentation;
	$state{'indent_str'} .= $indentation_str;
}

sub remove_nesting {
	if ($verbose >= 2) { warn ("[".$line_numbers[$pos]."] REMOVE: ".$state{'last_nesting'}."\n"); }
	$state{'indent'} -= $indentation;
	if ($state{'indent_str'} !~ s/${indentation_str}$//s) {
		fatal ("internal error while reducing the indentation string");
		return (1);
	}
	$state{'last_nesting'} = "";
	if ($state{'nesting'} =~ /([^\|]+)\|$/s) { $state{'last_nesting'} = $1; }
	return (0);
}

sub check_new_nesting {
	my ($line) = cut_comment (@_);
	if ($line =~ /\)then(?: |$)/is) {
		warning ("space is required before 'then'");
		$line =~ s/\)then( |$)/\) then${1}/is;
		$lines[$pos] =~ s/\)then( |$)/\) then${1}/is;
	}
	if ($state{'multiline_if'}) {
		$state{'multiline_if'} = 0;
		if ($line =~ / then$/is) { add_nesting ("if"); }
		if ($line =~ /\&$/s) { $state{'multiline_if'} = 1; }
		return (0);
	}
	if ($state{'multiline_where'}) {
		if ($line !~ /\&$/s) {
			$state{'multiline_where'} = 0;
			my $clean_line = cut_brackets ($state{'complete_line'}.$line);
			if ($clean_line !~ /\(_+\) *\S/s) { add_nesting ("where"); }
		}
		return (0);
	}
	if ($state{'else_branch'}) {
		add_nesting ($state{'else_branch'});
		$state{'else_branch'} = "";
		return (0);
	}
	for (my $index = 0; $index < $num_trigger_indent; $index++) {
		my $trigger = $trigger_indent[$index];
		my $label = "";
		if ($trigger eq "contains") {
			if ($line =~ /^ *contains$/is) {
				add_nesting ("");
				last;
			}
		}
		if ($line =~ /^ *([a-z0-9_]+) *: *${trigger}(?:[^a-z0-9_'"]|$)/is) {
			$label = $1;
			warning ("using labels for '".$trigger."'-statements is not recommended");
			$line =~ s/^( *)${label} *: *(?=${trigger})/${1}/is;
			$lines[$pos] =~ s/^( *)${label} *: *(?=${trigger})/${1}/is;
		}
		if ($line =~ /^ *${trigger}[^a-z0-9_'" ]/is) {
			warning ("space after '".$trigger."'-statement required");
			$line =~ s/^( *${trigger})/${1} /is;
			$lines[$pos] =~ s/^( *${trigger})/${1} /is;
		}
		if ($trigger eq "function") {
			my $type_list = join ("|", @data_types);
			$type_list =~ s/ / \+/gs;
			my $character_brackets = '(?: *\\([^\\(\\)]+\\))?';
			$type_list =~ s/character(\||$)/character${character_brackets}${1}/s;
			if ($line =~ s/^( *)($type_list) +function /${1}function /is) {
				picky_fixme_warning ("data type '".$2."' belongs inside the 'function' block");
			}
		}
		if ($line =~ /^ *${trigger} /is) {
			if ($line =~ / *<remove-MLC>$/s) {
				warning ("put each indentation-sensitive command in a separate line");
				$line =~ s/ *<remove-MLC>$//s;
				$lines[$pos] =~ s/ *<remove-MLC>$//s;
				$state{'fixed_multiple_commands'} = 1;
			}
			if (($trigger eq "module") && ($line =~ /^ *module +procedure /is)) { last; }
			if (($trigger eq "type") && ($line =~ /::/is)) { last; }
			if (($trigger eq "if") && ($line =~ /\&$/s)) {
				$state{'multiline_if'} = 1;
				last;
			}
			if (($trigger eq "if") && ($line !~ / then *$/is)) { last; }
			if (($trigger eq "where") && ($line =~ /\&$/s)) {
				$state{'multiline_where'} = 1;
				last;
			}
			if ($trigger eq "where") {
				my $clean_line = cut_brackets ($line);
				if ($clean_line =~ /\(_+\) *\S/s) { last; }
			}
			if ($label) { $trigger .= ' '.$label; }
			add_nesting ($trigger);
			last;
		}
	}
	return (0);
}

sub check_closed_nesting {
	my ($line) = cut_comment (@_);
	$line =~ s/^<auto-indent>//s;
	my $trigger_list = join ("|", @trigger_unindent);
	my $trigger = "";
	if ($line =~ s/ *<remove-MLC>$//s) {
		warning ("put each indentation-sensitive command in a separate line");
		$lines[$pos] =~ s/ *<remove-MLC>$//s;
		$state{'fixed_multiple_commands'} = 1;
	}
	if ($line =~ /^ *end *(${trigger_list})( +[a-z0-9_]+)?$/is) {
		$trigger = $1;
		my $label = $2;
		if ($trigger =~ /(?:subroutine|function|module|type)/is) { $label = ""; }
		if ($line =~ s/^( *end) +${trigger}/${1}${trigger}/is) {
			warning ("either use 'end".$trigger."' or a pure 'end'-statement");
			$lines[$pos] =~ s/^( *(?:<auto-indent> *)?end) +${trigger}/${1}${trigger}/is;
		}
		if ($label) {
			warning ("using labels for 'end".$trigger."'-statements is not recommended");
			$label =~ s/^ */ /s;
			$line =~ s/^( *end${trigger}) *${label}/${1}/is;
			$lines[$pos] =~ s/^( *(?:<auto-indent> *)?end${trigger}) *${label}/${1}/is;
		}
		if ($state{'nesting'} !~ s/(^|\|)${trigger}${label}(\|+)$/${1}${2}/is) {
			if ($verbose) { warn ("NESTING:".$state{'nesting'}." TRIGGER:".$trigger."\n"); }
			fatal ("misplaced 'end".$trigger.$label."' => expecting 'end".$state{'last_nesting'}."'");
			return (1);
		}
	}
	elsif ($line =~ /^ *end( +\S+)?$/is) {
		my $label = $1;
		if ($label) {
			accumulative_fatal ("nothing should follow after a pure 'end'-statements");
		}
		if ($state{'nesting'} !~ s/(^|\|)[^ \|]+(\|+)$/${1}${2}/s) { 
			fatal ("internal error while removing nesting");
			return (1);
		}
	}
	elsif ($line =~ /^ *else(.*?)$/is) {
		my $else = cut_comment ($1);
		my $type = $state{'last_nesting'};
		if ($else =~ /^ +${type}/s) {
			warning ("better use 'else".$type."' instead of 'else ".$type."'");
			$else =~ s/^ +//is;
			$line =~ s/^( *else) +${type}/${1}${type}/is;
			$lines[$pos] =~ s/^( *(?:<auto-indent> *)?else) +${type}/${1}${type}/is;
		}
		if ($else =~ /^${type}[^a-z0-9_ ]/is) {
			warning ("space after 'else".$type."'-statement required");
			$else =~ s/^${type}/${type} /is;
			$line =~ s/^( *else${type})/${1} /is;
			$lines[$pos] =~ s/^( *(?:<auto-indent> *)?else${type})/${1} /is;
		}
		if (($type eq "if") && ($else !~ /^$/s) && ($else !~ /\&$/s) && ($else !~ / then/is)) {
			# TODO: handle multi-line else-blocks correctly, currentyl just ignored
			fatal ("must place 'then' after 'elseif'");
			return (1);
		}
		elsif (($else =~ /^${type} /is) || (($type eq "if") && ($else =~ /^$/is)) || (($type eq "where") && ($else =~ /^${type}$/is))) {
			if ($state{'nesting'} !~ s/(^|\|)${type}\|$/${1}\|/s) {
				if ($verbose) { warn ("NESTING:".$state{'nesting'}." TYPE:".$type."\n"); }
				fatal ("misplaced 'else".$trigger."'");
				return (1);
			}
			$state{'else_branch'} = $type;
		}
		else {
			# unrecognized "else...", might be something like "elset = 1"
			return (0);
		}
	}
	elsif ($line =~ /^ *case([^a-z0-9_].*?)$/is && ($state{'last_nesting'} eq "select")) {
		my $case = $1;
		my $type = $state{'last_nesting'};
		if ($case !~ /^ /s) {
			warning ("space after 'case'-statement required");
			$case = " ".$case;
			$line =~ s/^( *case)/${1} /is;
			$lines[$pos] =~ s/^( *(?:<auto-indent> *)?case)/${1} /is;
		}
		if ($state{'nesting'} !~ s/(^|\|)${type}\|$/${1}\|/s) {
			if ($verbose) { warn ("NESTING:".$state{'nesting'}." TYPE:".$type."\n"); }
			fatal ("misplaced 'case'");
			return (1);
		}
		$state{'else_branch'} = $type;
	}
	else {
		# no end, nor else
		return (0);
	}
	if (($trigger eq "module") && ($state{'nesting'} =~ s/(^|\|)\|$/${1}/s)) {
		my $result = remove_nesting ();
		if ($result) { return (1); }
	}
	if ($state{'nesting'} =~ s/(^|\|)\|$/${1}/s) { return (remove_nesting ()); }
	return (0);
}

