#!/usr/bin/perl
#======================================================================#
# Name:   summarize-state
# Author: Bourdin.KIS
# Date:   02-Mar-2012
# SVN:    $Id$
# Description:
#    Evaluate 'params.log' and generate a proper 'run.in' for a given time.

use strict;

my $run_file = "run.in";
my $out_file = "run_<T>.in";
my $par_file = "data/params.log";

my $id = "[a-zA-Z](?:[a-zA-Z0-9_])*"; # allowed namelist/variable identifiers

my $progname = $0;
$progname =~ s/.*\///s;

my $usage="Usage:  $progname <time>
Evaluate $par_file and $run_file to generate a run.in file for a given <time>.

Options:
  -h, --help : This usage overview
";

if ((@ARGV <= 0) || ($ARGV[0] =~ /^(-h|--help)/)) { die $usage; }


my $time = $ARGV[0];
my $line = "";
my $log = "";
my $run = "";

# Read whole par_file and split contents by separator line
open (LOG, "< ".$par_file) || die ("Can't open file '$par_file'\n");
while ($line = <LOG>) { $log .= $line; }
close (LOG);

my @blocks = split (/^\s*[!#]\s*---------------------------------*\s*$/m, $log);

# Drop empty blocks
@blocks = grep /\S/, @blocks;

# Drop emtpy lines
@blocks = map { s/^\s*\n//gm; $_ } @blocks;

my $started = 0;
my $params = "";
my $block = "";
my $param = "";

foreach $block (@blocks) {

	# Find requested time and pick corresponding parameter block
	if ($block !~ /^\s*!\s*t\s*=\s*([\d\.e+\-]+)/im) { next; }
	if ($1 > $time) { last; }
	$started = $1;
	$params = $block;
}

my $comment = "Reference time: ".$started."\n";
$out_file =~ s/<T>/$started/is;
if ($params =~ /^\s*!\s*Date\s*:\s*(\S+\s\S+)/im) { $comment .= "Executed on: ".$1."\n"; }
print $comment;
$comment =~ s/^/! /gm;


# Read whole run_file and split contents by separator line
open (RUN, "< ".$run_file) || die ("Can't open file '$run_file'\n");
while ($line = <RUN>) {
	if ($line =~ /^\s*([^#=\s]+)\s*=/is) {
		$param = $1;
		if ($params =~ /^(\s*${param}\s*=.*)$/im) {
			$line = $1;
			$line =~ s/[\s,]*$/\n/is;
		}
		else { die ("Parse error for parameter '$param'.\n"); }
	}
	$run .= $line;
}
close (RUN);

open (OUT, "> ".$out_file) || die ("Can't open file '$out_file'\n");
print OUT $comment.$run;
close (OUT);

exit (0);

# ---------------------------------------------------------------------- #

sub canonical {
    # Return $line (a Fortran namelist) in a canonicalized form; basically
    # split it along (roughly guessed) separators between variables.
    my $line = shift;
    my ($head,$vars);
    my ($mark1,$mark2) = (".",":");

    if ($line =~ /^((?:\s*#[^\n]*\n)*)(.*)/s) {
        ($head,$vars) = ($1,$2);
        # Normalize and add marker, so diff will print all header lines
        chomp($head);
        $head =~ s/(^\s*#)/$1$mark1/gm;

#       print STDERR "HEAD:<$head>\n";
#       print STDERR "VARS:<", substr($vars,0,50),">\n";

        $vars =~ s/\n//g;       # join namelist stuff
        # Separate different namelists by newlines:
        $vars =~ s{(/?)\s*(\&$id)}{\n$1\n$2\n}g; # `.. / &next_nl var=val ..'
        $vars =~ s{/\s*$}{\n/}; # Final `/'

        # Pretty-print the special `impossible' value (needs to be adapted
        # for different output formats used by different compilers)
        $vars =~ s/3\.90850*[EeDd]\+?0?37/<impossible>/g;

        # Now split between variables and splice in newlines
        my @vars = split_vars($vars);
        join("\n",$head,@vars);
    } else {
        printf STDERR "Something fishy with entry (no header or so):\n";
        my $quoted = $line;
        $quoted =~ s/\n/\\n/g;
        $quoted =~ s/\s\s+/ /g;
        printf STDERR "  " . substr("$quoted",0,70) . " [..]\n";
        "";
    }
}

sub split_vars {
    # Split $line into individual assignments `var=val', separated by a
    # newline from the following assignment.

    my $line = shift;
    $line =~ s/,?\s?($id\s*=)/\n$1/g;

    $line;
}


